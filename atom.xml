<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-03-12T02:37:33.602Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>底层一：OC对象</title>
    <link href="http://example.com/2021/03/08/%E5%BA%95%E5%B1%82%E4%B8%80%EF%BC%9A%E5%AF%B9%E8%B1%A1/"/>
    <id>http://example.com/2021/03/08/%E5%BA%95%E5%B1%82%E4%B8%80%EF%BC%9A%E5%AF%B9%E8%B1%A1/</id>
    <published>2021-03-08T03:36:07.000Z</published>
    <updated>2021-03-12T02:37:33.602Z</updated>
    
    <content type="html"><![CDATA[<p><strong>OC对象本质是C++的结构体：因为对象涉及到不同类型，只有结构体能存储不同的结构体</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)test &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">其实是系统会传递两个参数过来</span><br><span class="line"></span><br><span class="line"><span class="comment">// self 方法调用者</span></span><br><span class="line"><span class="comment">// _cmd 方法名，等价于当前方法的selector，既@selector(test)</span></span><br><span class="line">- (<span class="keyword">void</span>)testId:(<span class="keyword">id</span>)<span class="keyword">self</span> _cmd:(SEL)_cmd &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//转化成CPP</span></span><br><span class="line"><span class="keyword">void</span> test(MJPerson* <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="oc-dui-xiang-de-ben-zhi">OC对象的本质</span><a href="#oc-dui-xiang-de-ben-zhi" class="header-anchor">#</a></h2><h4><span id="jiang-oc-dai-ma-zhuan-huan-cheng-wei-c-c-dai-ma">将OC代码转换成为C\C++代码</span><a href="#jiang-oc-dai-ma-zhuan-huan-cheng-wei-c-c-dai-ma" class="header-anchor">#</a></h4><p>这里最好新建项目创建两个类进行转换，因为要遵从一些上下文，否则会转换失败</p><blockquote><p>切换到文件目录，使用命令行<br><code>clang -rewrite-objc xxxx.m -o xxx.cpp</code><br>直接切换到iOS下64位系统可以使用的CPP代码<br><code>xcrun  -sdk  iphoneos  clang  -arch  arm64  -rewrite-objc  xxxx.m  -o  xxx.cpp </code></p></blockquote><h5><span id="cha-kan-oc-yuan-ma-di-zhi">查看OC源码地址</span><a href="#cha-kan-oc-yuan-ma-di-zhi" class="header-anchor">#</a></h5><p><a href="https://opensource.apple.com/tarballs/">OC源码 数字最大的是最新的 objc 4</a></p><blockquote><p><code>Core Foundation </code>硬性规定对象占用十六字节</p></blockquote><h5><span id="mian-shi-ti">面试题：</span><a href="#mian-shi-ti" class="header-anchor">#</a></h5><p><strong>一个NSObject对象占用多少内存？</strong></p><blockquote><p>系统分配了<code>16个字节</code>给<code>NSObject</code>对象（通过<code>malloc_size</code>函数获得）</p><p>但<code>NSObject</code>对象内部只使用了<code>8个字节</code>的空间（<code>64bit</code>环境下，可以通过<code>class_getInstanceSize</code>函数获得）</p></blockquote><p><code>OC</code> 转换为<code>C++</code>后，查看对象的实现，一般是<code>类型_IMPL</code>形式，<code>Student</code>转换后就是 <code>Student_IMPL</code></p><p>查看<code>class_getInstanceSize</code>的实现（<code>.mm</code> 文件），在<code>Objc 4</code> 中</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;malloc/malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NSObject Implementation</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="built_in">NSObject_IMPL</span> &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//typedef struct objc_class *Class; // 64位占8个字节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// insert code here...</span></span><br><span class="line">        <span class="built_in">NSObject</span> *obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%zd&quot;</span>,class_getInstanceSize([<span class="built_in">NSObject</span> <span class="keyword">class</span>])); <span class="comment">// 8</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%zd&quot;</span>, malloc_size((__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)obj)); <span class="comment">// 16</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">class_getInstanceSize</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> cls-&gt;alignedInstanceSize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Class&#x27;s ivar size rounded up to a pointer-size boundary. (返回类的成员变量的大小)</span></span><br><span class="line">    <span class="function"><span class="keyword">uint32_t</span> <span class="title">alignedInstanceSize</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> word_align(unalignedInstanceSize());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">alloc 实际是调用 allocWithZone</span><br><span class="line"></span><br><span class="line">--------------------- 类： NSObject.mm ---------------------</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Replaced by ObjectAlloc</span><br><span class="line">+ (id)allocWithZone:(struct _NSZone *)zone &#123;</span><br><span class="line">    return _objc_rootAllocWithZone(self, (malloc_zone_t *)zone);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------------- 类： Objc-runtime-new.mm ---------------------</span><br><span class="line"></span><br><span class="line">_objc_rootAllocWithZone(Class cls, malloc_zone_t *zone __unused)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; allocWithZone under __OBJC2__ ignores the zone parameter</span><br><span class="line">    return _class_createInstanceFromZone(cls, 0, nil,</span><br><span class="line">                                         OBJECT_CONSTRUCT_CALL_BADALLOC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------------- 类 objc-runtime-new.mm  ---------------------</span><br><span class="line"></span><br><span class="line">static ALWAYS_INLINE id</span><br><span class="line">_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone,</span><br><span class="line">                              int construct_flags &#x3D; OBJECT_CONSTRUCT_NONE,</span><br><span class="line">                              bool cxxConstruct &#x3D; true,</span><br><span class="line">                              size_t *outAllocatedSize &#x3D; nil)</span><br><span class="line">&#123;</span><br><span class="line">    ............</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    size_t size;</span><br><span class="line"></span><br><span class="line">    size &#x3D; cls-&gt;instanceSize(extraBytes);</span><br><span class="line"></span><br><span class="line">    if (outAllocatedSize) *outAllocatedSize &#x3D; size;</span><br><span class="line"></span><br><span class="line">    id obj;</span><br><span class="line">    if (zone) &#123;</span><br><span class="line">        obj &#x3D; (id)malloc_zone_calloc((malloc_zone_t *)zone, 1, size);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        obj &#x3D; (id)calloc(1, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ............</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------------- 类：objc-runtime-new.h  ---------------------</span><br><span class="line">inline size_t instanceSize(size_t extraBytes) const &#123;</span><br><span class="line">        if (fastpath(cache.hasFastInstanceSize(extraBytes))) &#123;</span><br><span class="line">            return cache.fastInstanceSize(extraBytes);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        size_t size &#x3D; alignedInstanceSize() + extraBytes;</span><br><span class="line">        &#x2F;&#x2F; CF requires all objects be at least 16 bytes.</span><br><span class="line">        if (size &lt; 16) size &#x3D; 16;   &#96;&#96;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>if (size &lt; 16) size = 16;</code> 主要是这句，是<code>Core Foundation</code>框架 硬性规定的</p><p><strong>查看过程：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> 1. 将OC转换成C++代码，可以看到的NSObject的本质是一个结构体，其中包含了一个isa指针，占用了8个字节</span><br><span class="line">&#x2F;&#x2F; NSObject Implementation</span><br><span class="line">struct NSObject_IMPL &#123;</span><br><span class="line">    Class isa; &#x2F;&#x2F; 8个字节</span><br><span class="line">&#125;;</span><br><span class="line"> 2. 查看源码</span><br><span class="line"> size_t class_getInstanceSize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cls) return 0;</span><br><span class="line">    return cls-&gt;alignedInstanceSize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Class&#39;s ivar size rounded up to a pointer-size boundary.</span><br><span class="line">&#x2F;&#x2F; 获取到类的实例对象的成员变量所占用的大小</span><br><span class="line">    uint32_t alignedInstanceSize() &#123;</span><br><span class="line">        return word_align(unalignedInstanceSize());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>查看alloc分配内存的过程</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.在源码中搜索allocWithZone，找到实现函数 </span></span><br><span class="line"></span><br><span class="line">id</span><br><span class="line">_objc_rootAllocWithZone(Class cls, <span class="keyword">malloc_zone_t</span> *zone)</span><br><span class="line">&#123;</span><br><span class="line">    id obj;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">    <span class="comment">// allocWithZone under __OBJC2__ ignores the zone parameter</span></span><br><span class="line">    (<span class="keyword">void</span>)zone;</span><br><span class="line">    obj = class_createInstance(cls, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">if</span> (!zone) &#123;</span><br><span class="line">        obj = class_createInstance(cls, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        obj = class_createInstanceFromZone(cls, <span class="number">0</span>, zone);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slowpath(!obj)) obj = callBadAllocHandler(cls);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 查看class_createInstance函数</span></span><br><span class="line">id </span><br><span class="line">class_createInstance(Class cls, <span class="keyword">size_t</span> extraBytes)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _class_createInstanceFromZone(cls, extraBytes, nil);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">id</span><br><span class="line">_class_createInstanceFromZone(Class cls, <span class="keyword">size_t</span> extraBytes, <span class="keyword">void</span> *zone, </span><br><span class="line">                              <span class="keyword">bool</span> cxxConstruct = <span class="literal">true</span>, </span><br><span class="line">                              <span class="keyword">size_t</span> *outAllocatedSize = nil)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> nil;</span><br><span class="line"></span><br><span class="line">    assert(cls-&gt;isRealized());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read class&#x27;s info bits all at once for performance</span></span><br><span class="line">    <span class="keyword">bool</span> hasCxxCtor = cls-&gt;hasCxxCtor();</span><br><span class="line">    <span class="keyword">bool</span> hasCxxDtor = cls-&gt;hasCxxDtor();</span><br><span class="line">    <span class="keyword">bool</span> fast = cls-&gt;canAllocNonpointer();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> size = cls-&gt;instanceSize(extraBytes);</span><br><span class="line">    <span class="keyword">if</span> (outAllocatedSize) *outAllocatedSize = size;</span><br><span class="line"></span><br><span class="line">    id obj;</span><br><span class="line">    <span class="keyword">if</span> (!zone  &amp;&amp;  fast) &#123;</span><br><span class="line">        obj = (id)<span class="built_in">calloc</span>(<span class="number">1</span>, size);</span><br><span class="line">        <span class="keyword">if</span> (!obj) <span class="keyword">return</span> nil;</span><br><span class="line">        obj-&gt;initInstanceIsa(cls, hasCxxDtor);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (zone) &#123;</span><br><span class="line">            obj = (id)malloc_zone_calloc ((<span class="keyword">malloc_zone_t</span> *)zone, <span class="number">1</span>, size);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            obj = (id)<span class="built_in">calloc</span>(<span class="number">1</span>, size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!obj) <span class="keyword">return</span> nil;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Use raw pointer isa on the assumption that they might be </span></span><br><span class="line">        <span class="comment">// doing something weird with the zone or RR.</span></span><br><span class="line">        obj-&gt;initIsa(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cxxConstruct &amp;&amp; hasCxxCtor) &#123;</span><br><span class="line">        obj = _objc_constructOrFree(obj, cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. 查看cls-&gt;instanceSize(extraBytes);</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">instanceSize</span><span class="params">(<span class="keyword">size_t</span> extraBytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">size_t</span> size = alignedInstanceSize() + extraBytes;</span><br><span class="line">        <span class="comment">// CF requires all objects be at least 16 bytes.</span></span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">16</span>) size = <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">可以看出Core Foundation框架要求对象至少占用<span class="number">16</span>个字节</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cfd1eb2296a748fca91f6ccf6d033caf~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-03-11 下午3.20.26.png"></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb7fceadadca427f8113fc1d78da19b4~tplv-k3u1fbpfcp-watermark.image" alt="test_xcodeproj.png"></p><p><code>计算机中的正数用源码表示，负数用补码表示，而负数的补码是其反码+1 所以出现了-128 简单的说为了避免-0，负数的算法结果是每位都加了1</code></p><h5><span id="ios-shi-xiao-duan-mo-shi-zai-nei-cun-zhong-cong-gao-wei-xiang-di-wei-du-qu-shu-ju">iOS是<code>小端</code>模式，在内存中从高位向低位读取数据</span><a href="#ios-shi-xiao-duan-mo-shi-zai-nei-cun-zhong-cong-gao-wei-xiang-di-wei-du-qu-shu-ju" class="header-anchor">#</a></h5><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e54c9730cf8043fe8d749f20ad8fa8a9~tplv-k3u1fbpfcp-watermark.image" alt="Interview01-OC对象的本质_xcodeproj.png"></p><p><strong>内存对齐</strong>： 结构体的大小必须是<code>最大成员</code>大小的倍数<br><strong>iOS内部操作系统</strong>：内存分配是16的倍数</p><h2><span id="instance-dui-xiang-shi-li-dui-xiang-class-dui-xiang-lei-dui-xiang-meta-class-dui-xiang-yuan-lei-dui-xiang">instance对象（实例对象）、class对象（类对象）、meta_class对象（元类对象）</span><a href="#instance-dui-xiang-shi-li-dui-xiang-class-dui-xiang-lei-dui-xiang-meta-class-dui-xiang-yuan-lei-dui-xiang" class="header-anchor">#</a></h2><h4><span id="instance-dui-xiang-shi-li-dui-xiang">instance对象（实例对象）</span><a href="#instance-dui-xiang-shi-li-dui-xiang" class="header-anchor">#</a></h4><ul><li><p><code>instance对象</code>在内存中存储的信息包括 ：<code>isa</code>指针（也是成员变量）、其他<code>成员变量</code></p></li><li><p><code>isa</code>的地址，就是<code>instance对象</code>的地址，因为<code>isa</code>总是在首部</p></li></ul><h4><span id="class-dui-xiang-lei-dui-xiang">class对象（类对象）</span><a href="#class-dui-xiang-lei-dui-xiang" class="header-anchor">#</a></h4><p>每个类在内存中有且只有一个<code>class</code>对象</p><p>runtime 源码 在objc4 里面</p><h2><span id="isa-he-superclass">isa和superClass</span><a href="#isa-he-superclass" class="header-anchor">#</a></h2><h2><span id="instance-dui-xiang-class-dui-xiang-meta-class-dui-xiang">instance对象、class对象、meta_class对象</span><a href="#instance-dui-xiang-class-dui-xiang-meta-class-dui-xiang" class="header-anchor">#</a></h2><h4><span id="instance-dui-xiang">instance对象</span><a href="#instance-dui-xiang" class="header-anchor">#</a></h4><h5><span id="mei-ge-instance-dui-xiang-chuang-jian-chu-lai-tong-guo-alloc-init-chuang-jian-fang-fa-du-zhi-you-yi-fen-yin-wei-fang-fa-shi-xiang-tong-de-fang-dao-lei-de-fang-fa-lie-biao-zhong-bu-fang-zai-dui-xiang-de-jie-gou-ti-zhong">每个instance对象创建出来（通过<code>alloc</code>、<code>init</code>创建），方法都只有一份，因为方法是相同的，放到类的方法列表中 （不放在<code>对象</code>的结构体中）</span><a href="#mei-ge-instance-dui-xiang-chuang-jian-chu-lai-tong-guo-alloc-init-chuang-jian-fang-fa-du-zhi-you-yi-fen-yin-wei-fang-fa-shi-xiang-tong-de-fang-dao-lei-de-fang-fa-lie-biao-zhong-bu-fang-zai-dui-xiang-de-jie-gou-ti-zhong" class="header-anchor">#</a></h5><blockquote><p> 一个类的类对象（class对象）是唯一的，在内存中只会开辟一份存储空间</p></blockquote><h4><span id="isa-zhi-zhen-xiang-shun-xu">isa指针向顺序</span><a href="#isa-zhi-zhen-xiang-shun-xu" class="header-anchor">#</a></h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f8518f7ad7842919185a1737b227b45~tplv-k3u1fbpfcp-zoom-1.image" alt="屏幕快照 2018-07-15 18.33.02.png"></p><h4><span id="class-dui-xiang-de-superclass-zhi-zhen">class对象的superClass指针</span><a href="#class-dui-xiang-de-superclass-zhi-zhen" class="header-anchor">#</a></h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e19e11d1f61a4c9a970e6af2b0de8894~tplv-k3u1fbpfcp-zoom-1.image" alt="屏幕快照 2018-07-15 19.18.56.png"></p><h4><span id="isa-he-superclass-zong-jie">isa和superClass总结</span><a href="#isa-he-superclass-zong-jie" class="header-anchor">#</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class object_getClass(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (obj) return obj-&gt;getIsa();</span><br><span class="line">    else return Nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/561733e1ad5a4d4294d327f9c23d364c~tplv-k3u1fbpfcp-zoom-1.image" alt="屏幕快照 2018-07-16 22.53.37.png"></p><ul><li>注意点：基类的元类的superClass指针，指向基类的类对象</li></ul><h4><span id="isa-zhi-zhen-xi-jie">isa指针细节</span><a href="#isa-zhi-zhen-xi-jie" class="header-anchor">#</a></h4><p>ISA_MASK 去源码里面获取</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cbb894957aa4bb8b66d040f8bbce6ed~tplv-k3u1fbpfcp-zoom-1.image" alt="屏幕快照 2018-07-18 23.19.09.png"></p><h5><span id="jian-ce-fang-shi">检测方式</span><a href="#jian-ce-fang-shi" class="header-anchor">#</a></h5><h6><span id="shi-li-dui-xiang">实例对象</span><a href="#shi-li-dui-xiang" class="header-anchor">#</a></h6><p>定义一个类<code>MJPerson</code>，创建一个<code>instance对象</code>(实例对象)和一个<code>Class对象</code>（类对象），断点打印对应的<code>isa</code>地址。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e57246c8b8e4e1a9b18921eca26f54e~tplv-k3u1fbpfcp-zoom-1.image" alt="打印指针 2018-07-18 23.23.01.png"></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afe0d96a154140bb82491579b459d1c6~tplv-k3u1fbpfcp-watermark.image" alt="未命名.png"></p><h6><span id="lei-dui-xiang">类对象</span><a href="#lei-dui-xiang" class="header-anchor">#</a></h6><p>因为<code>类对象</code>的isa指针无法通过程序直接打印，可以创建一个结构体模仿<code>类对象</code>的实现，然后进行打印</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mj_objc_class</span> &#123;</span></span><br><span class="line">    Class isa;</span><br><span class="line">    Class superclass;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mj_objc_class</span> *<span class="title">personClass</span> =</span> (__bridge struct mj_objc_class *)([MJPerson class]);</span><br><span class="line">从而得出</span><br><span class="line">personClass-&gt;isa &amp; ISA_MASK：<span class="number">0x00000001000014c8</span> = meta_class </span><br></pre></td></tr></table></figure><h4><span id="kui-tan-struct-objc-class-de-jie-gou-lei-dui-xiang-he-yuan-lei-dui-xiang-dui-ying-de-jie-gou-ti">窥探struct objc_class的结构 (类对象和元类对象对应的结构体)</span><a href="#kui-tan-struct-objc-class-de-jie-gou-lei-dui-xiang-he-yuan-lei-dui-xiang-dui-ying-de-jie-gou-ti" class="header-anchor">#</a></h4><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fca529bcb6c043b4b23050c5292b169e~tplv-k3u1fbpfcp-watermark.image" alt="01-OC语法.png"></p><h4><span id="super-he-superclass-de-qu-bie">super 和 superClass的区别</span><a href="#super-he-superclass-de-qu-bie" class="header-anchor">#</a></h4><ul><li>self就是给谁发消息，不一定是当前类，谁接受消息，self就代表谁</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">Test</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#import &quot;NSObject+Test.h&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">Test</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//+ (void)test</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    NSLog(@&quot;+[NSObject test] - %p&quot;, self);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">- (<span class="keyword">void</span>)test</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// self就是给谁发消息，不一定是当前类，谁接受消息，self就代表谁</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;-[NSObject test] - %p&quot;</span>, <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MJPerson</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MJPerson</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//+ (void)test</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    NSLog(@&quot;+[MJPerson test] - %p&quot;, self);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;[MJPerson class] - %p&quot;</span>, [MJPerson <span class="keyword">class</span>]);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;[NSObject class] - %p&quot;</span>, [<span class="built_in">NSObject</span> <span class="keyword">class</span>]);</span><br><span class="line">        <span class="comment">// OC对象的调用方法，就是发送消息，发送过程中不会注意到是类方法还是对象方法</span></span><br><span class="line">        [MJPerson test];</span><br><span class="line">        <span class="comment">// objc_msgSend([MJPerson class], @selector(test))</span></span><br><span class="line">        <span class="comment">// isa -&gt; superclass -&gt; suerpclass -&gt; superclass -&gt; .... superclass == nil</span></span><br><span class="line">        </span><br><span class="line">        [<span class="built_in">NSObject</span> test];</span><br><span class="line">        <span class="comment">// objc_msgSend([NSObject class], @selector(test))</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 打印结果</span></span><br><span class="line"><span class="comment">         [MJPerson class] - 0x1000011e0</span></span><br><span class="line"><span class="comment">         [NSObject class] - 0x7fff8d775140</span></span><br><span class="line"><span class="comment">         // self就是给谁发消息，不一定是当前类，谁接受消息，self就代表谁,所以这里的打印虽然发生在NSObject的分类中，但是其实消息是发送给MJPerson的，所以打印出的self是MJPerson的类对象</span></span><br><span class="line"><span class="comment">         [NSObject test] - 0x1000011e0</span></span><br><span class="line"><span class="comment">         [NSObject test] - 0x7fff8d775140</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;OC对象本质是C++的结构体：因为对象涉及到不同类型，只有结构体能存储不同的结构体&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s</summary>
      
    
    
    
    
    <category term="底层" scheme="http://example.com/tags/%E5%BA%95%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>底层二：KVO、KVC</title>
    <link href="http://example.com/2021/03/08/%E5%BA%95%E5%B1%82%E4%BA%8C%EF%BC%9AKVO%E3%80%81KVC/"/>
    <id>http://example.com/2021/03/08/%E5%BA%95%E5%B1%82%E4%BA%8C%EF%BC%9AKVO%E3%80%81KVC/</id>
    <published>2021-03-08T03:36:07.000Z</published>
    <updated>2021-03-12T06:57:58.332Z</updated>
    
    <content type="html"><![CDATA[<h4><span id="kvo">KVO</span><a href="#kvo" class="header-anchor">#</a></h4><ul><li>通过打印<code>被监听实例对象</code>的<code>isa</code>指针，可以发现，被监听实例对象的<code>isa</code>不再指向类对象，而是指向<code>NSKVONotifying_MJPerson</code></li><li><code>NSKVONotifying_MJPerson</code>是使用<code>Runtime</code>动态创建的一个类，是<code>MJPerson</code>的子类</li></ul><p><code>NSKVONotifying_MJPerson</code> 伪代码 </p><ul><li> 通过<code>[self.person1 methodForSelector:@selector(setAge:)]</code>获取方法实现的地址</li><li>通过LLDB 的命令<code>p (IMP)0x1069189e4</code> 获取方法的名称</li></ul><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90a57963daa04a68b34827ab6ae3656d~tplv-k3u1fbpfcp-watermark.image" alt="未命名.png"> </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;MJPerson.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSKVONotifying_MJPerson</span> : <span class="title">MJPerson</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;NSKVONotifying_MJPerson.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSKVONotifying_MJPerson</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setAge:(<span class="keyword">int</span>)age</span><br><span class="line">&#123;</span><br><span class="line">    _NSSetIntValueAndNotify();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="keyword">void</span> _NSSetIntValueAndNotify()</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@&quot;age&quot;</span>];</span><br><span class="line">    [<span class="keyword">super</span> setAge:age];</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@&quot;age&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)didChangeValueForKey:(<span class="built_in">NSString</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 通知监听器，某某属性值发生了改变</span></span><br><span class="line">    [oberser observeValueForKeyPath:key ofObject:<span class="keyword">self</span> change:<span class="literal">nil</span> context:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>NSKVONotifying_MJPerson</code> <code>类对象</code>指向自己的<code>元类对象</code></p><blockquote><p>未使用KVO监听的对象</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/294b9e145f2547e7b7071aa0dfd64446~tplv-k3u1fbpfcp-zoom-1.image" alt="kvo1.png"></p><blockquote><p>使用KVO监听的对象</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/451faca4c49344a6a28abafd74ca9f76~tplv-k3u1fbpfcp-zoom-1.image" alt="kvo2.png"></p><blockquote><p><strong>总结</strong>：使用了<code>KVO</code>，会产生一个<code>MJPerson</code>的子类(<code>NSKVONotifying_MJPerson</code>)，会改变<code>MJPerson</code>的<code>isa</code>指向新产生的子类，同时在新的子类里面会重写<code>setAge:</code>方法，以及新增三个方法</p></blockquote><p>获取方法数组</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)printMethodNamesOfClass:(Class)cls</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="comment">// 获得方法数组</span></span><br><span class="line">    Method *methodList = class_copyMethodList(cls, &amp;count);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存储方法名</span></span><br><span class="line">    <span class="built_in">NSMutableString</span> *methodNames = [<span class="built_in">NSMutableString</span> string];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历所有的方法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">// 获得方法</span></span><br><span class="line">        Method method = methodList[i];</span><br><span class="line">        <span class="comment">// 获得方法名</span></span><br><span class="line">        <span class="built_in">NSString</span> *methodName = <span class="built_in">NSStringFromSelector</span>(method_getName(method));</span><br><span class="line">        <span class="comment">// 拼接方法名</span></span><br><span class="line">        [methodNames appendString:methodName];</span><br><span class="line">        [methodNames appendString:<span class="string">@&quot;, &quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放</span></span><br><span class="line">    free(methodList);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印方法名</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ %@&quot;</span>, cls, methodNames);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到 NSKVONotifying_MJPerson 内部的方法名</p><table><thead><tr><th>NSKVONotifying_MJPerson</th><th>类型</th><th>实现</th></tr></thead><tbody><tr><td><code>setAge:</code></td><td>重写</td><td>实现<code>Foundation</code>的<code>_NSSetIntValueAndNotify</code>方法</td></tr><tr><td><code>class</code></td><td>新增</td><td>屏蔽内部实现，隐藏了<code>NSKVONotifying_MJPerson</code>类对象</td></tr><tr><td><code>dealloc</code></td><td>新增</td><td>清理现场</td></tr><tr><td><code>_isKVOA</code></td><td>新增</td><td></td></tr></tbody></table><p><code>_NSSetIntValueAndNotify</code>内部实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. [self willChangeValueForKey:@&quot;age&quot;]</span><br><span class="line">2. 原来的setter实现</span><br><span class="line">3. [self didChangeValueForKey:@&quot;age&quot;]</span><br><span class="line"></span><br><span class="line">didChangeValueForKey:内部会调用observer的observeValueForKeyPath:ofObject:change:context:方法</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>_NSSet*ValueAndNotify</code> 包括很多的基本数据类型<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf4db93f991d4a71be2db5b479d8ecb2~tplv-k3u1fbpfcp-zoom-1.image" alt="kvo3.png"></p><h4><span id="kvc">KVC</span><a href="#kvc" class="header-anchor">#</a></h4><p>使用<code>KVC</code>设置属性时候，会触发<code>KVO</code>,即使没有set方法，也会触发KVO，因为KVC底层调用了<code>- (void)willChangeValueForKey:(NSString *)key</code> 和 <code>- (void)didChangeValueForKey:(NSString *)key</code> 两个方法</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be0279c442104cb1a6a360f0895eb987~tplv-k3u1fbpfcp-zoom-1.image" alt="kvc1.png"><br>举例： 查找顺序(属性名为<code>age</code>) <code>_age</code> <code>_isAge</code> <code>age</code> <code>isAge</code></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/626c3898dadc4ce18b25faa3626f1f25~tplv-k3u1fbpfcp-zoom-1.image" alt="kvc2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4&gt;&lt;span id=&quot;kvo&quot;&gt;KVO&lt;/span&gt;&lt;a href=&quot;#kvo&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt;&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;通过打印&lt;code&gt;被监听实例对象&lt;/code&gt;的&lt;code&gt;isa&lt;/code&gt;指针，可以发现，被监听实例对</summary>
      
    
    
    
    
    <category term="底层" scheme="http://example.com/tags/%E5%BA%95%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>底层六：runLoop</title>
    <link href="http://example.com/2021/03/08/%E5%BA%95%E5%B1%82%E5%85%AD%EF%BC%9ArunLoop/"/>
    <id>http://example.com/2021/03/08/%E5%BA%95%E5%B1%82%E5%85%AD%EF%BC%9ArunLoop/</id>
    <published>2021-03-08T03:36:07.000Z</published>
    <updated>2021-03-22T10:24:36.727Z</updated>
    
    <content type="html"><![CDATA[<p>在 <code>LLDB</code> 中 打印 <code>bt</code> 就可以打印函数调用栈</p><p><a href="https://opensource.apple.com/tarballs/CF/">RunLoop源码</a></p><h4><span id="jian-jie">简介</span><a href="#jian-jie" class="header-anchor">#</a></h4><p><code>RunLoop：</code>运行循环<br><code>概念：</code>  一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能<code>随时处理事件但并不退出</code></p><h5><span id="ying-yong-fan-chou">应用范畴：</span><a href="#ying-yong-fan-chou" class="header-anchor">#</a></h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">定时器（Timer）、PerformSelector</span><br><span class="line">GCD Async Main Queue</span><br><span class="line">事件响应、手势识别、界面刷新</span><br><span class="line">网络请求</span><br><span class="line">AutoreleasePool</span><br></pre></td></tr></table></figure><p><strong>如果没有运行循环的情况下</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// insert code here...</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Hello, World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在执行了第5行代码后，程序会自动退出</span></span><br></pre></td></tr></table></figure><p><strong>如果有了运行循环</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 程序并不会马上退出，而是保持运行状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> retVal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 睡眠中等待消息</span></span><br><span class="line">            <span class="keyword">int</span> message = sleep_and_wait();</span><br><span class="line">            <span class="comment">// 处理消息</span></span><br><span class="line">            retVal = process_message(message);</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="number">0</span> == retVal) ;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5><span id="runloop-de-ji-ben-zuo-yong">RunLoop的基本作用</span><a href="#runloop-de-ji-ben-zuo-yong" class="header-anchor">#</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">保持程序的持续运行</span><br><span class="line">处理App中的各种事件（比如触摸事件、定时器事件等）</span><br><span class="line">节省CPU资源，提高程序性能：该做事时做事，该休息时休息</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h4><span id="runloop-dui-xiang">Runloop对象</span><a href="#runloop-dui-xiang" class="header-anchor">#</a></h4><p><strong>iOS 中有两套API来访问和使用RunLoop</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Foundation：<span class="built_in">NSRunLoop</span></span><br><span class="line">Core Foundation：<span class="built_in">CFRunLoopRef</span></span><br></pre></td></tr></table></figure><p><code>NSRunLoop</code>和<code>CFRunLoopRef</code>都代表着<code>RunLoop</code>对象<br><code>NSRunLoop</code>是基于<code>CFRunLoopRef</code>的一层OC包装<br><code>CFRunLoopRef</code>是<a href="https://opensource.apple.com/tarballs/CF/">开源</a>的</p><h4><span id="runloop-yu-xian-cheng">RunLoop与线程</span><a href="#runloop-yu-xian-cheng" class="header-anchor">#</a></h4><blockquote><ul><li><code>每条线程</code>都有<code>唯一</code>的一个与之对应的<code>RunLoop</code>对象</li><li> <code>RunLoop</code>保存在一个<code>全局的Dictionary</code>里，线程作为<code>key</code>，<code>RunLoop</code>作为<code>value</code></li><li> 线程刚创建时并没有<code>RunLoop</code>对象，<code>RunLoop</code>会在第一次获取它时创建</li><li> <code>RunLoop</code>会在线程结束时销毁</li><li> 主线程的<code>RunLoop</code>已经自动获取（创建），子线程默认没有开启<code>RunLoop</code></li></ul></blockquote><p><strong>获取RunLoop对象</strong><br><code>Foundation</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">NSRunLoop</span> currentRunLoop]; <span class="comment">// 获得当前线程的RunLoop对象</span></span><br><span class="line">[<span class="built_in">NSRunLoop</span> mainRunLoop]; <span class="comment">// 获得主线程的RunLoop对象</span></span><br></pre></td></tr></table></figure><p><code>Core Foundation</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFRunLoopGetCurrent</span>(); <span class="comment">// 获得当前线程的RunLoop对象</span></span><br><span class="line"><span class="built_in">CFRunLoopGetMain</span>(); <span class="comment">// 获得主线程的RunLoop对象</span></span><br></pre></td></tr></table></figure><p><strong>打印</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%p %p&quot;</span>, [<span class="built_in">NSRunLoop</span> mainRunLoop], [<span class="built_in">NSRunLoop</span> currentRunLoop]);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%p %p&quot;</span>, <span class="built_in">CFRunLoopGetMain</span>(), <span class="built_in">CFRunLoopGetCurrent</span>());    </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,[<span class="built_in">NSRunLoop</span> mainRunLoop]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0x60000069aa60 0x60000069aa60</span></span><br><span class="line"><span class="comment">// 0x600001e98d00 0x600001e98d00</span></span><br><span class="line"><span class="comment">// &lt;CFRunLoop 0x600001e98d00 [0x10eeefb68]&gt;</span></span><br></pre></td></tr></table></figure><p> 通过打印结果可以看出，<code>NSRunLoop</code>对象是基于<code>CFRunLoop</code>的一层封装</p><h4><span id="mode">Mode</span><a href="#mode" class="header-anchor">#</a></h4><h5><span id="source0">source0</span><a href="#source0" class="header-anchor">#</a></h5><ul><li>处理<code>触摸</code>事件<br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a51717b0e4184e54b9d39aa313228901~tplv-k3u1fbpfcp-watermark.image"></li></ul><ul><li>处理 <code>performSelector:onThread:withObject:waitUntilDone:</code>和<code>performSelector:onThread:withObject:waitUntilDone:modes:</code>事件<br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc84515ea71b4d5db16c01fb7817e812~tplv-k3u1fbpfcp-watermark.image"></li></ul><h5><span id="source1">source1</span><a href="#source1" class="header-anchor">#</a></h5><ul><li>基于<code>port</code>的线程间通信</li><li>系统事件的捕捉（触摸事件是<code>source1</code>捕捉，包装成<code>source0</code>处理）</li></ul><h5><span id="timer">Timer</span><a href="#timer" class="header-anchor">#</a></h5><ul><li><code>NSTimer</code></li><li><code>performSelector:withObject:afterDelay:</code></li></ul><h5><span id="observers">Observers</span><a href="#observers" class="header-anchor">#</a></h5><ul><li>用于监听<code>runLoop</code>状态</li><li>UI刷新(<code>beforeWaiting</code>)</li><li>Autorelease Pool</li></ul><h5><span id="runloop-xiang-guan-de-lei">RunLoop相关的类</span><a href="#runloop-xiang-guan-de-lei" class="header-anchor">#</a></h5><p><code>Core Foundation</code>中关于<code>RunLoop</code>的5个类</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFRunLoopRef</span></span><br><span class="line"><span class="built_in">CFRunLoopModeRef</span></span><br><span class="line"><span class="built_in">CFRunLoopSourceRef</span></span><br><span class="line"><span class="built_in">CFRunLoopTimerRef</span></span><br><span class="line"><span class="built_in">CFRunLoopObserverRef</span></span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd56df84d8d5461793f8771a64524c10~tplv-k3u1fbpfcp-zoom-1.image" alt="图片 1.png"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65827269ad944cc4982c55d0bbb105b0~tplv-k3u1fbpfcp-zoom-1.image" alt="图片 2.png"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d2553b2a2914cf8af6cbe94ba06653c~tplv-k3u1fbpfcp-zoom-1.image" alt="图片 3.png"></p><blockquote><ul><li> <code>CFRunLoopModeRef</code>代表<code>RunLoop</code>的运行模式</li></ul></blockquote><blockquote><ul><li> 一个<code>RunLoop</code>包含若干个<code>Mode</code>，每个<code>Mode</code>又包含若干个<code>Source0/Source1/Timer/Observer</code></li></ul></blockquote><blockquote><ul><li> <code>RunLoop</code>启动时只能选择其中一个<code>Mode</code>，作为<code>currentMode</code></li></ul></blockquote><blockquote><ul><li>如果需要切换<code>Mode</code>，只能退出<code>当前Loop</code>，再重新选择一个<code>Mode</code>进入<br> ———&gt; 不同组的<code>Source0/Source1/Timer/Observer</code>能分隔开来，互不影响</li></ul></blockquote><blockquote><ul><li> 如果<code>Mode</code>里没有任何<code>Source0/Source1/Timer/Observer</code>，<code>RunLoop</code>会立马退出</li></ul></blockquote><h5><span id="cfrunloopmoderef">CFRunLoopModeRef</span><a href="#cfrunloopmoderef" class="header-anchor">#</a></h5><p><strong>常见的2种Mode</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kCFRunLoopDefaultMode（<span class="built_in">NSDefaultRunLoopMode</span>）：App的默认Mode，通常主线程是在这个Mode下运行</span><br><span class="line"><span class="built_in">UITrackingRunLoopMode</span>：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响</span><br></pre></td></tr></table></figure><h5><span id="cfrunloopobserverref-runloop-de-liu-chong-zhuang-tai">CFRunLoopObserverRef (runLoop的六种状态)</span><a href="#cfrunloopobserverref-runloop-de-liu-chong-zhuang-tai" class="header-anchor">#</a></h5><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c748dd15f564f8db79908c83977baf8~tplv-k3u1fbpfcp-zoom-1.image" alt="图片 4.png"></p><p><strong>添加Observer监听RunLoop的所有状态</strong><br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/683117188fea4da19212c84f3c0f932f~tplv-k3u1fbpfcp-zoom-1.image" alt="图片 5.png"></p><p><strong>监听Mode的转变</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Observer</span></span><br><span class="line">    <span class="built_in">CFRunLoopObserverRef</span> observer = <span class="built_in">CFRunLoopObserverCreateWithHandler</span>(kCFAllocatorDefault, kCFRunLoopAllActivities, <span class="literal">YES</span>, <span class="number">0</span>, ^(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (activity) &#123;</span><br><span class="line">            <span class="keyword">case</span> kCFRunLoopEntry: &#123;</span><br><span class="line">                <span class="built_in">CFRunLoopMode</span> mode = <span class="built_in">CFRunLoopCopyCurrentMode</span>(<span class="built_in">CFRunLoopGetCurrent</span>());</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopEntry - %@&quot;</span>, mode);</span><br><span class="line">                <span class="built_in">CFRelease</span>(mode);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">case</span> kCFRunLoopExit: &#123;</span><br><span class="line">                <span class="built_in">CFRunLoopMode</span> mode = <span class="built_in">CFRunLoopCopyCurrentMode</span>(<span class="built_in">CFRunLoopGetCurrent</span>());</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopExit - %@&quot;</span>, mode);</span><br><span class="line">                <span class="built_in">CFRelease</span>(mode);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// kCFRunLoopCommonModes默认包括kCFRunLoopDefaultMode、UITrackingRunLoopMode</span></span><br><span class="line">    <span class="comment">// 添加Observer到RunLoop中</span></span><br><span class="line">    <span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopGetMain</span>(), observer, kCFRunLoopCommonModes);</span><br><span class="line">    <span class="comment">// 释放</span></span><br><span class="line">    <span class="built_in">CFRelease</span>(observer);</span><br></pre></td></tr></table></figure><h4><span id="runloop-de-yun-xing-luo-ji">RunLoop的运行逻辑</span><a href="#runloop-de-yun-xing-luo-ji" class="header-anchor">#</a></h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7839915fcef64bc99df463f52c724eda~tplv-k3u1fbpfcp-zoom-1.image" alt="图片 6.png"></p><table><thead><tr><th align="left"><code>Mode</code>类型</th><th align="right"></th><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="left"><code>Source0</code></td><td align="right">触摸事件处理</td><td align="center">performSelector:onThread:</td><td align="center"></td></tr><tr><td align="left"><code>Source1</code></td><td align="right">基于Port的线程间通信</td><td align="center">系统事件捕捉</td><td align="center"></td></tr><tr><td align="left"><code>Timers</code></td><td align="right">NSTimer</td><td align="center">performSelector:withObject:afterDelay:</td><td align="center"></td></tr><tr><td align="left"><code>Observers</code></td><td align="right">用于监听RunLoop的状态</td><td align="center">UI刷新（BeforeWaiting）</td><td align="center">Autorelease pool（BeforeWaiting）</td></tr></tbody></table><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/056c40992cd749cb8408e661d84a7ff0~tplv-k3u1fbpfcp-zoom-1.image" alt="图片 7.png"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0073edaae3b45b499dd849cd0331446~tplv-k3u1fbpfcp-zoom-1.image"></p><h5><span id="runloop-xiu-mian-de-shi-xian-yuan-li">RunLoop休眠的实现原理</span><a href="#runloop-xiu-mian-de-shi-xian-yuan-li" class="header-anchor">#</a></h5><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d466342e66542d1970e245f4e20d5ed~tplv-k3u1fbpfcp-zoom-1.image" alt="图片 8.png"></p><h5><span id="runloop-zai-shi-ji-kai-zhong-de-ying-yong">RunLoop在实际开中的应用</span><a href="#runloop-zai-shi-ji-kai-zhong-de-ying-yong" class="header-anchor">#</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">控制线程生命周期（线程保活）</span><br><span class="line">解决NSTimer在滑动时停止工作的问题</span><br><span class="line">监控应用卡顿</span><br><span class="line">性能优化</span><br></pre></td></tr></table></figure><p>补充：</p><p><code>GCD</code>很多东西是不依赖<code>RunLoop</code>的，<code>GCD</code>执行流程是与<code>RunLoop</code>是分开的，但是<code>GCD</code>有一种情况是交给<code>RunLoop</code>处理就是<code>线程间通信</code></p><p><code>NSTimer失效</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">1.0</span> repeats:<span class="literal">YES</span> block:^(<span class="built_in">NSTimer</span> * _Nonnull timer) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>, ++count);</span><br><span class="line">    &#125;];</span><br><span class="line"><span class="comment">//    [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];</span></span><br><span class="line"><span class="comment">//    [[NSRunLoop currentRunLoop] addTimer:timer forMode:UITrackingRunLoopMode];</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// NSDefaultRunLoopMode、UITrackingRunLoopMode才是真正存在的模式</span></span><br><span class="line">    <span class="comment">// NSRunLoopCommonModes并不是一个真的模式，它只是一个标记</span></span><br><span class="line">    <span class="comment">// timer能在_commonModes数组中存放的模式下工作</span></span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br></pre></td></tr></table></figure><h4><span id="runloop-de-ying-yong">RunLoop的应用</span><a href="#runloop-de-ying-yong" class="header-anchor">#</a></h4><h5><span id="chu-li-nstimer-he-uiscrollview-de-chong-tu">处理<code>NSTimer</code>和<code>UIScrollView</code>的冲突</span><a href="#chu-li-nstimer-he-uiscrollview-de-chong-tu" class="header-anchor">#</a></h5><h5><span id="xian-cheng-bao-huo">线程保活</span><a href="#xian-cheng-bao-huo" class="header-anchor">#</a></h5><blockquote><p><code>warning：</code> 一般<code>initWithTarget：</code>容易造成循环引用</p></blockquote><p><code>NSRunLoop</code>的<code>run</code>方法，用于开启<code>无限循环</code>的线程</p><p>使用懒加载的时候一定要注意的情况：当<code>_thread</code>是懒加载时</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!_thread) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>如果写成</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.thread) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>会造成循环引用</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 &lt;code&gt;LLDB&lt;/code&gt; 中 打印 &lt;code&gt;bt&lt;/code&gt; 就可以打印函数调用栈&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://opensource.apple.com/tarballs/CF/&quot;&gt;RunLoop源码&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;&lt;spa</summary>
      
    
    
    
    
    <category term="底层" scheme="http://example.com/tags/%E5%BA%95%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>网络安全</title>
    <link href="http://example.com/2021/03/08/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    <id>http://example.com/2021/03/08/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/</id>
    <published>2021-03-08T03:36:07.000Z</published>
    <updated>2021-03-08T06:08:26.001Z</updated>
    
    <content type="html"><![CDATA[<p>网络通信中面临的4种安全威胁 </p><ul><li><code>截取</code>：窃听通信内容 </li><li><code>中断</code>：中断网络通信 </li><li><code>篡改</code>：篡改通信内容 </li><li><code>伪造</code>：伪造通信内容<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee47563f23034943b7beabce49a45ac7~tplv-k3u1fbpfcp-watermark.image"> <h4><span id="wang-luo-ceng-arp-qi-pian">网络层 - ARP欺骗</span><a href="#wang-luo-ceng-arp-qi-pian" class="header-anchor">#</a></h4></li><li><code>ARP欺骗</code>(ARP spoofing)，又称<code>ARP毒化</code>(ARP poisoning)、<code>ARP病毒</code>、<code>ARP攻击</code> </li><li><code>ARP欺骗</code>可以造成的效果 <ul><li>可让攻击者获取局域网上的数据包甚至可篡改数据包</li><li>可让网络上特定电脑之间无法正常通信 (例如<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E6%89%A7%E6%B3%95%E5%AE%98/4891462">网络执法官</a>这样的软件) </li><li>让送至特定<code>IP</code>地址的流量被错误送到攻击者所取代的地方 </li><li>等等 </li></ul></li></ul><h5><span id="he-xin-bu-zou-ju-li">核心步骤举例</span><a href="#he-xin-bu-zou-ju-li" class="header-anchor">#</a></h5><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d4ad1a6adb54dd890b19ad65de26de7~tplv-k3u1fbpfcp-watermark.image"> </p><h5><span id="fang-hu">防护</span><a href="#fang-hu" class="header-anchor">#</a></h5><ul><li>静态<code>ARP</code> </li><li><code>DHCP Snooping</code>:网络设备可以借由<code>DHCP</code>保留网络上各电脑的<code>MAC</code>地址，在伪造的<code>ARP</code>数据包发出时即可侦测到 </li><li>利用一些软件监听<code>ARP</code>的不正常变动 </li></ul><h4><span id="dos-ddos">Dos、DDoS</span><a href="#dos-ddos" class="header-anchor">#</a></h4><ul><li><code>DoS攻击</code>(拒绝服务攻击，Denial-Of-Service attack): 使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问 </li><li><code>DDoS攻击</code>(分布式拒绝服务攻击，Distribution Denial-Of-Service attack)：黑客使用网络上两个或以上被攻陷的电脑作为“僵尸(肉鸡)”，向特定的目标发动<code>DoS</code>攻击 &gt; 2018年3月，GitHub遭到迄今为止规模最大的DDoS攻击</li><li><code>DoS</code> 攻击可以分为2大类 <ul><li>带宽消耗型：<code>UDP</code>洪水攻击、<code>ICMP</code>洪水攻击 </li><li>资源消耗型：<code>SYN</code>洪水攻击、<code>LAND</code>攻击 </li></ul></li></ul><h5><span id="fang-yu">防御</span><a href="#fang-yu" class="header-anchor">#</a></h5><ul><li><p><code>防御方式</code>通常为：入侵检测、流量过滤和多重验证，堵塞网络带宽的流量将被过滤，而正常的流量可正常通过 </p></li><li><p><code>防火墙</code> </p><ul><li>防火墙可以设置规则，例如允许或拒绝特定通讯协议，端口或IP地址 </li><li>当攻击从少数不正常的IP地址发出时，可以简单的使用拒绝规则阻止一切从攻击源IP发出的通信 </li><li>复杂攻击难以用简单规则来阻止，例如80端口遭受攻击时，不可能拒绝端口所有的通信，因为同时会阻止合法流量 </li><li>防火墙可能处于网络框架中过后的位置，路由器可能再恶意流量到达防火墙前即被攻击影响 </li></ul></li><li><p><code>交换机</code>：大多数交换机有一定的速度限制和访问控制能力 </p></li><li><p><code>路由器</code>：和交换机类似，路由器也有一定的速度限制和访问控制能力 </p></li><li><p><code>黑洞引导</code>:将所有受攻击计算机的通信全部发送至一个“黑洞”（空接口或不存在的计算机地址）或者有足够能力处理洪流的网络设备商，以避免网络受到较大的影响 </p></li><li><p><code>流量清洗</code>：当流量被送到DDoS防护清洗中心时，通过采用抗DDoS软件处理，将正常流量和恶意流量区分开，正常的流量则回注回客户网站 </p></li></ul><h4><span id="chuan-shu-ceng-syn-hong-shui-gong-ji">传输层 — SYN洪水攻击</span><a href="#chuan-shu-ceng-syn-hong-shui-gong-ji" class="header-anchor">#</a></h4><ul><li>SYN洪水攻击(SYN flooding attack) 攻击者发送一系列SYN请求到目标，然后让目标因收不到ACK（第三次握手）而进行等待、消耗资源 </li><li>攻击方法 <ul><li>跳过发送最后的ACK信息 </li><li>修改源IP地址，让目标送SYN-ACK到伪造的IP地址，因此目标永不可能收到ACK（第三次握手） </li></ul></li><li>防护，参考<a href="https://tools.ietf.org/html/rfc4987">RFC 4987</a> </li></ul><h4><span id="chuan-shu-ceng-land-gong-ji">传输层 — LAND攻击</span><a href="#chuan-shu-ceng-land-gong-ji" class="header-anchor">#</a></h4><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9284c4d3d26d451e9d0a791adb7acfa9~tplv-k3u1fbpfcp-watermark.image"> </p><h4><span id="ying-yong-ceng-dns-jie-chi">应用层 - DNS劫持</span><a href="#ying-yong-ceng-dns-jie-chi" class="header-anchor">#</a></h4><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f5d990aefe544d38481e035074a5c5e~tplv-k3u1fbpfcp-watermark.image"></p><h4><span id="http-xie-yi-de-an-quan-wen-ti">HTTP协议的安全问题</span><a href="#http-xie-yi-de-an-quan-wen-ti" class="header-anchor">#</a></h4><p><code>HTTP协议</code>默认是采取明文传输的，因此会有很大的安全隐患，常见的提高安全性的方法是：对通信内容进行<code>加密</code>后，再进行传输 </p><h5><span id="chang-jian-de-jia-mi-fang-shi">常见的加密方式</span><a href="#chang-jian-de-jia-mi-fang-shi" class="header-anchor">#</a></h5><p><strong>不可逆</strong> </p><blockquote><ul><li>单向散列函数： MD5、SHA等 </li></ul></blockquote><p><strong>可逆</strong> </p><blockquote><ul><li>对称加密：DES、3DES、AES等 </li><li>非对称加密：RSA 等 </li></ul></blockquote><p><strong>其他</strong> </p><blockquote><ul><li>混合密码系统 </li><li>数字签名 </li><li>证书 </li></ul></blockquote><p><strong>常见英文</strong> </p><p><code>encrypt</code>(加密) <code>decrypt</code>(解密) <code>plaintext</code>(明文) <code>ciphertext</code>(密文) </p><p><strong>人物设计</strong> </p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44dd04a696ba4a95a7354d5aa09cd1e3~tplv-k3u1fbpfcp-watermark.image"> </p><p><strong>如何防止被窃听？</strong> </p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7e0a479be3546fb86481cb5a3a6218b~tplv-k3u1fbpfcp-watermark.image"> </p><h4><span id="dan-xiang-san-lie-han-shu">单向散列函数</span><a href="#dan-xiang-san-lie-han-shu" class="header-anchor">#</a></h4><p>几个散列函数网站：<a href="https://www.cmd5.com/hash.aspx">MD5加密</a>、<a href="https://www.cmd5.com/">MD5解密</a>、<a href="https://www.sojson.com/encrypt_des.html">其他加密</a>、<a href="https://tool.chinaz.com/tools/md5.aspx">其他</a> </p><p><code>单向散列函数（One-way hash function）</code>：可以根据消息内容计算出散列值 散列值的长度和消息的长度无关，无论消息是<code>1bit</code>、<code>10M</code>、<code>100G</code>，单向散列函数都会计算出固定长度的散列值 </p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b0f0b38ad8241dfb636106611a42ee1~tplv-k3u1fbpfcp-watermark.image"> </p><h5><span id="san-lie-han-shu-te-dian">散列函数特点</span><a href="#san-lie-han-shu-te-dian" class="header-anchor">#</a></h5><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c798115063224f2aa2d2a41712136120~tplv-k3u1fbpfcp-watermark.image"> </p><h5><span id="san-lie-han-shu-cheng-hu">散列函数称呼</span><a href="#san-lie-han-shu-cheng-hu" class="header-anchor">#</a></h5><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/316ef52a511f495a8c6a1d4c103b5ad5~tplv-k3u1fbpfcp-watermark.image"> </p><h5><span id="chang-jian-de-ji-chong-dan-xiang-san-lie-han-shu">常见的几种单向散列函数</span><a href="#chang-jian-de-ji-chong-dan-xiang-san-lie-han-shu" class="header-anchor">#</a></h5><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f4c97731c8b4e4f8462f679e8eab039~tplv-k3u1fbpfcp-watermark.image"> </p><h5><span id="ru-he-fang-zhi-shu-ju-bei-cuan-gai-dui-bi-liang-tian-de-wen-jian-xian-ran-bu-xian-shi-gen-ju-wen-jian-ji-suan-chu-san-lie-zhi-kan-liang-tian-de-dui-bi-shi-fou-yi-zhi">如何防止数据被篡改 对比两天的文件，显然不现实，根据文件计算出散列值，看两天的对比是否一致</span><a href="#ru-he-fang-zhi-shu-ju-bei-cuan-gai-dui-bi-liang-tian-de-wen-jian-xian-ran-bu-xian-shi-gen-ju-wen-jian-ji-suan-chu-san-lie-zhi-kan-liang-tian-de-dui-bi-shi-fou-yi-zhi" class="header-anchor">#</a></h5><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04372da8657d4c5d8598de11c6c12637~tplv-k3u1fbpfcp-watermark.image"> </p><h5><span id="ying-yong-wang-zhan-realvnc-ti-gong-yi-ge-san-lie-zhi-sha-256-xia-zai-wan-cheng-hou-wen-jian-jin-xing-san-lie-dui-bi-ru-guo-yi-zhi-zheng-ming-zai-jing-xiang-xia-zai-de-wen-jian-mei-you-wen-ti">应用 网站提供一个散列值（<code>SHA-256</code>），下载完成后文件进行散列对比，如果一直，证明在镜像下载的文件没有问题</span><a href="#ying-yong-wang-zhan-realvnc-ti-gong-yi-ge-san-lie-zhi-sha-256-xia-zai-wan-cheng-hou-wen-jian-jin-xing-san-lie-dui-bi-ru-guo-yi-zhi-zheng-ming-zai-jing-xiang-xia-zai-de-wen-jian-mei-you-wen-ti" class="header-anchor">#</a></h5><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/202c92282e0b47968bf7dea364239e15~tplv-k3u1fbpfcp-watermark.image"> </p><p>进行数据库的账户密码存储，用户注册时候，数据层存储的密码应该是进行加密后的密码 </p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb2df6f2194d43e2a63bf54136b3a8a1~tplv-k3u1fbpfcp-watermark.image"> </p><h4><span id="ru-he-jia-mi-jie-mi">如何加密解密？</span><a href="#ru-he-jia-mi-jie-mi" class="header-anchor">#</a></h4><p>对称加密/非对称加密 主要就是<code>密钥</code>、<code>算法</code>，接下来我们也重点关注这两项 </p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3021349f06a046dcb8447f4ee4b23a83~tplv-k3u1fbpfcp-watermark.image"> </p><h4><span id="dui-cheng-jia-mi-you-cheng-dui-cheng-mi-ma">对称加密（又称对称密码）</span><a href="#dui-cheng-jia-mi-you-cheng-dui-cheng-mi-ma" class="header-anchor">#</a></h4><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e39cd8fbd48841fd9c7c030800f33338~tplv-k3u1fbpfcp-watermark.image"> </p><p>在对称加密中，加密、解密时使用的是<code>同一个密钥</code> 常见的对称加密算法有 <code>DES</code>、<code>3DES</code>、 <code>AES</code> </p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35ab790378314da19921f13a53210730~tplv-k3u1fbpfcp-watermark.image"> </p><h5><span id="des-data-encryption-standard">DES (Data Encryption Standard)</span><a href="#des-data-encryption-standard" class="header-anchor">#</a></h5><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8958d9ea1ad949b689ad0ff23f660229~tplv-k3u1fbpfcp-watermark.image"> </p><h5><span id="3des-triple-data-encryption-algorithm">3DES(Triple Data Encryption Algorithm)</span><a href="#3des-triple-data-encryption-algorithm" class="header-anchor">#</a></h5><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/387ef92ad0584bc0912b737ded06f957~tplv-k3u1fbpfcp-watermark.image"> </p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e826b3156f84d99bec5dd2109aceb50~tplv-k3u1fbpfcp-watermark.image"> </p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f38b2ddd14f4c06a0b529d3e18a80d6~tplv-k3u1fbpfcp-watermark.image"> </p><h5><span id="aes-advanced-encryption-standard">AES (Advanced Encryption Standard)</span><a href="#aes-advanced-encryption-standard" class="header-anchor">#</a></h5><ul><li>取代<code>DES</code>成为新标准的一种对称加密算法，又称<code>Rijndael</code>加密算法 </li><li><code>AES</code>的密钥长度有<code>128</code>、<code>192</code>、<code>256</code>bit三种 </li><li>目前<code>AES</code>，已经逐步取代<code>DES</code>、<code>3DES</code>，成为首选的对称加密算法 </li><li>一般来说，我们也不应该去使用任何自制的密码算法，而是应该使用<code>AES</code>，它经过了全世界密码学家所进行的高品质验证工作 </li></ul><h5><span id="mi-yao-pei-song-wen-ti">密钥配送问题</span><a href="#mi-yao-pei-song-wen-ti" class="header-anchor">#</a></h5><ul><li>使用对称加密时，一定会遇到密钥配送的问题 </li><li>如果Alice将使用对称加密过的消息发送给了Bob，只有将密钥发送给Bob，Bob才能完成解密，但是在发送过程中，密钥可能被Eve窃取，最后Eve也能完成解密 </li></ul><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0940b8545a9a47b5881e0f64020f4ab6~tplv-k3u1fbpfcp-watermark.image"> </p><p><strong>如何解决密钥配送问题？</strong> </p><ul><li>事先共享密钥 （比如私下共享） </li><li>密钥分配中心 (key Distribution Center, 简称KDC) </li><li>Diffie-Hellman密钥交换 </li><li>使用<code>非对称加密</code>配送 </li></ul><h4><span id="fei-dui-cheng-jia-mi-asymmetric-cryptography">非对称加密 (Asymmetric Cryptography)</span><a href="#fei-dui-cheng-jia-mi-asymmetric-cryptography" class="header-anchor">#</a></h4><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cda83cc99677434eba1e58d0fe520e55~tplv-k3u1fbpfcp-watermark.image"></p><ul><li>在<strong>非对称加密</strong>中，密钥分为<code>加密密钥</code>、<code>解密密钥</code>2种，它们并不是同一个密钥 </li><li><strong>加密密钥</strong>：一般是公开的，因此该密钥成为<code>公钥</code>(<code>public key</code>),因此<strong>非对称加密</strong>也被成为<code>公钥秘密</code>(<code>Public-key Cryptography</code>) </li><li><strong>解密密钥</strong>：由消息接收者自己保管的，不能公开，因此也称为<code>私钥(Private Key)</code><br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73823d15635642e4b1d6d03631e47bd8~tplv-k3u1fbpfcp-watermark.image"></li></ul><h5><span id="gong-yao-si-yao">公钥、私钥</span><a href="#gong-yao-si-yao" class="header-anchor">#</a></h5><ul><li>公钥和私钥是一一对应的，不能单独生成，一对公钥和私钥统称为<code>密钥对(key pair)</code> </li><li>由<code>公钥</code>加密的密文，必须使用与该<code>公钥</code>相应的<code>私钥</code>才能解密 </li><li>由<code>私钥</code>加密的密文，必须使用与该<code>私钥</code>相应的<code>公钥</code>才能解密（用于签名认证） </li></ul><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9288d64e6b654db3b17daf560ea7bb1d~tplv-k3u1fbpfcp-watermark.image"> </p><h5><span id="jie-jue-mi-yao-pei-song-wen-ti">解决密钥配送问题</span><a href="#jie-jue-mi-yao-pei-song-wen-ti" class="header-anchor">#</a></h5><ul><li><p>由消息的<code>接收者</code>，生成一对公钥、私钥 </p></li><li><p>将公钥发给消息的发送者 * 消息的发送者使用公钥加密消息，消息的接收者使用私钥解密消息 </p></li><li><p><strong>非对称加密</strong>的加密速度<strong>比对称加密</strong>要慢 </p></li></ul><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4044b2cee8ea45d586f4d4199ea5c4c7~tplv-k3u1fbpfcp-watermark.image"> </p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32751acad35047ecb55bfe1a7f349c68~tplv-k3u1fbpfcp-watermark.image"> </p><h5><span id="rsa">RSA</span><a href="#rsa" class="header-anchor">#</a></h5><ul><li>目前使用最广泛的<strong>非对称加密</strong>算法是RSA </li><li>RSA的名字是由它的三位开发者的姓氏首字母组成 </li></ul><h4><span id="hun-he-mi-ma-xi-tong-hybrid-cryptosystem">混合密码系统 (Hybrid Cryptosystem)</span><a href="#hun-he-mi-ma-xi-tong-hybrid-cryptosystem" class="header-anchor">#</a></h4><ul><li><strong>对称加密</strong>的缺点：不能很好的解决密钥配送问题(密钥会被窃听) </li><li><strong>非对称加密</strong>的缺点：加密解密速度比较慢 </li><li><strong>混合密码系统</strong>：是将对称加密和非对称加密的优势相结合的方法 <blockquote><p>解决了非对称加密速度慢的问题 </p><p>并通过非对称加密解决了对称加密的密钥配送问题 </p></blockquote></li><li>网络上的密码通信所用的<code>SSL/TLS</code> 都运用了混合密码系统 </li></ul><h5><span id="jia-mi">加密</span><a href="#jia-mi" class="header-anchor">#</a></h5><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd726f9190664087b5b88f72e510563a~tplv-k3u1fbpfcp-watermark.image"><br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/869a194a83494bda8970fcfa9f4b84b4~tplv-k3u1fbpfcp-watermark.image"></p><h5><span id="jie-mi">解密</span><a href="#jie-mi" class="header-anchor">#</a></h5><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c02df9d47d27467391b7a95f2c5e62d6~tplv-k3u1fbpfcp-watermark.image"><br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd3c11bc9ab2457b8022bb96eae6ecc1~tplv-k3u1fbpfcp-watermark.image"> </p><p><strong>加密解密流程</strong> </p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c2dc62987424a4481d846d89bdc6c34~tplv-k3u1fbpfcp-watermark.image"> </p><h4><span id="shu-zi-qian-ming">数字签名</span><a href="#shu-zi-qian-ming" class="header-anchor">#</a></h4><p><strong>想象以下场景</strong> </p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/055dfb9a552544989ca589fc9bc2f3a4~tplv-k3u1fbpfcp-watermark.image"><br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/831b01d6b09645098602bb948c65ddb3~tplv-k3u1fbpfcp-watermark.image"> </p><p><strong>过程</strong> </p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc3e4c233f87444e96f07589206d02d0~tplv-k3u1fbpfcp-watermark.image"> </p><p>由于加密整条消息，信息量大而且非对称机密速度慢，因此进行了改进，求出消息的散列值(<code>具有唯一性</code>)进行加密 </p><p><strong>改进过程</strong> </p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fdcf3205786f4dc4be7844c2be3bb126~tplv-k3u1fbpfcp-watermark.image"> </p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1273f7513e1a4223947ad76586936bc9~tplv-k3u1fbpfcp-watermark.image"> </p><p><strong>疑惑</strong> </p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88d59a504f444f539c7f3f274973e54b~tplv-k3u1fbpfcp-watermark.image"> </p><p><strong>公钥、私钥总结</strong> </p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/338122cd7eec44778338d6800c50395f~tplv-k3u1fbpfcp-watermark.image"> </p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc625a48c4124c8a9de630e24074e946~tplv-k3u1fbpfcp-watermark.image"> </p><h4><span id="zheng-shu">证书</span><a href="#zheng-shu" class="header-anchor">#</a></h4><p>如果遭遇了中间人攻击，那么，<code>公钥将可能是伪造的</code>，如何验证公钥的合法性？ <strong>证书</strong></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4386431ec06348c1ad08f272964a847f~tplv-k3u1fbpfcp-watermark.image"> </p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/674c2399125146729677e6ed84567228~tplv-k3u1fbpfcp-watermark.image"> </p><h5><span id="zheng-shu-shi-yong">证书使用</span><a href="#zheng-shu-shi-yong" class="header-anchor">#</a></h5><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0db39acb2176444491ac19ae7c26b509~tplv-k3u1fbpfcp-watermark.image"> </p><ul><li>各大<code>CA</code>的公钥，默认已经内置在浏览器和操作系统中，也就避免了获取证书的公钥再度被劫持 </li></ul><h5><span id="zhu-ce-he-xia-zai">注册和下载</span><a href="#zhu-ce-he-xia-zai" class="header-anchor">#</a></h5><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6eb13cfbb03346b5a83c29843668ebf0~tplv-k3u1fbpfcp-watermark.image"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;网络通信中面临的4种安全威胁 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;截取&lt;/code&gt;：窃听通信内容 &lt;/li&gt;
&lt;li&gt;&lt;code&gt;中断&lt;/code&gt;：中断网络通信 &lt;/li&gt;
&lt;li&gt;&lt;code&gt;篡改&lt;/code&gt;：篡改通信内容 &lt;/li&gt;
&lt;li&gt;&lt;code&gt;伪造&lt;</summary>
      
    
    
    
    
    <category term="网络" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>底层三：Category</title>
    <link href="http://example.com/2021/03/08/%E5%BA%95%E5%B1%82%E4%B8%89%EF%BC%9Acategory/"/>
    <id>http://example.com/2021/03/08/%E5%BA%95%E5%B1%82%E4%B8%89%EF%BC%9Acategory/</id>
    <published>2021-03-08T03:36:07.000Z</published>
    <updated>2021-03-15T07:58:52.549Z</updated>
    
    <content type="html"><![CDATA[<h4><span id="category">category</span><a href="#category" class="header-anchor">#</a></h4><p><code>category</code>中的方法是通过<code>runtime</code>动态的将分类的方法合并到类对象、元类对象中</p><p><strong>最后面参与编译的分类，方法的实现在最前面</strong></p><p><code>category</code> 的底层CPP结构是 <code>_category_t</code>，一个分类对应一个结构体对象，然后通过runtime将方法合并到类对象中</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;MJPerson.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MJPerson</span> (<span class="title">Eat</span>) &lt;<span class="title">NSCopying</span>, <span class="title">NSCoding</span>&gt;</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)eat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="keyword">int</span> weight;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="keyword">double</span> height;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .m</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;MJPerson+Eat.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MJPerson</span> (<span class="title">Eat</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)run</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;MJPerson (Eat) - run&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)eat</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;eat&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)eat1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;eat1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)eat2</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)eat3</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>转换后</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">category_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">// 类名</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">class_t</span> *<span class="title">cls</span>;</span> <span class="comment">//</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">method_list_t</span> *<span class="title">instance_methods</span>;</span> <span class="comment">// 对象方法</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">method_list_t</span> *<span class="title">class_methods</span>;</span>   <span class="comment">//  类方法</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span>   <span class="comment">//  协议</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">prop_list_t</span> *<span class="title">properties</span>;</span>   <span class="comment">//  属性</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">利用结构体创建出一个对象 OBJC_$_CATEGORY_MJPerson_$_Eat</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> _<span class="title">category_t</span> _<span class="title">OBJC_</span>$_<span class="title">CATEGORY_MJPerson_</span>$_<span class="title">Eat</span> __<span class="title">attribute__</span> ((<span class="title">used</span>, <span class="title">section</span> (&quot;__<span class="title">DATA</span>,__<span class="title">objc_const</span>&quot;))) =</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;MJPerson&quot;</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="comment">// &amp;OBJC_CLASS_$_MJPerson,</span></span><br><span class="line">    (<span class="keyword">const</span> struct <span class="keyword">_method_list_t</span> *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_MJPerson_$_Eat,</span><br><span class="line">    (<span class="keyword">const</span> struct <span class="keyword">_method_list_t</span> *)&amp;_OBJC_$_CATEGORY_CLASS_METHODS_MJPerson_$_Eat,</span><br><span class="line">    (<span class="keyword">const</span> struct <span class="keyword">_protocol_list_t</span> *)&amp;_OBJC_CATEGORY_PROTOCOLS_$_MJPerson_$_Eat,</span><br><span class="line">    (<span class="keyword">const</span> struct <span class="keyword">_prop_list_t</span> *)&amp;_OBJC_$_PROP_LIST_MJPerson_$_Eat,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这些是不同的结构体，去转换后的代码里看</span></span><br><span class="line">_OBJC_$_CATEGORY_INSTANCE_METHODS_MJPerson_$_Eat </span><br><span class="line">_OBJC_$_CATEGORY_CLASS_METHODS_MJPerson_$_Eat</span><br><span class="line">…… …… …… </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里要通过转换后的CPP代码去看，编译完成后，<code>类名、对象方法、类方法、协议、属性</code> 存放到了结构体 <code>_category_t</code> 底层结构中，并没有合并到<code>类对象</code>中，在程序运行时，runtime会将category的数据，合并到类对象(元类对象)中</p><p>分类的加载处理过程</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b1670ec3e2c4a79b6c25998b95f791c~tplv-k3u1fbpfcp-watermark.image" alt="01-OC语法.png"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d46a1a2164394469a47017e32c004e37~tplv-k3u1fbpfcp-zoom-1.image" alt="category"></p><ul><li><p>后面参与<code>编译</code>的<code>Category</code>数据，会在数组的前面(优先调用)</p></li><li><p>使用<code>msg_send</code>发送消息的调用顺序<code>1.分类  2.父类</code> （比对子类和父类没有意义）</p></li></ul><h4><span id="load-fang-fa">+load方法</span><a href="#load-fang-fa" class="header-anchor">#</a></h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* call_load_methods</span></span><br><span class="line"><span class="comment">* Call all pending class and category +load methods.</span></span><br><span class="line"><span class="comment">* Class +load methods are called superclass-first. </span></span><br><span class="line"><span class="comment">* Category +load methods are not called until after the parent class&#x27;s +load.</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* This method must be RE-ENTRANT, because a +load could trigger </span></span><br><span class="line"><span class="comment">* more image mapping. In addition, the superclass-first ordering </span></span><br><span class="line"><span class="comment">* must be preserved in the face of re-entrant calls. Therefore, </span></span><br><span class="line"><span class="comment">* only the OUTERMOST call of this function will do anything, and </span></span><br><span class="line"><span class="comment">* that call will handle all loadable classes, even those generated </span></span><br><span class="line"><span class="comment">* while it was running.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* The sequence below preserves +load ordering in the face of </span></span><br><span class="line"><span class="comment">* image loading during a +load, and make sure that no </span></span><br><span class="line"><span class="comment">* +load method is forgotten because it was added during </span></span><br><span class="line"><span class="comment">* a +load call.</span></span><br><span class="line"><span class="comment">* Sequence:</span></span><br><span class="line"><span class="comment">* 1. Repeatedly call class +loads until there aren&#x27;t any more</span></span><br><span class="line"><span class="comment">* 2. Call category +loads ONCE.</span></span><br><span class="line"><span class="comment">* 3. Run more +loads if:</span></span><br><span class="line"><span class="comment">*    (a) there are more classes to load, OR</span></span><br><span class="line"><span class="comment">*    (b) there are some potential category +loads that have </span></span><br><span class="line"><span class="comment">*        still never been attempted.</span></span><br><span class="line"><span class="comment">* Category +loads are only run once to ensure &quot;parent class first&quot; </span></span><br><span class="line"><span class="comment">* ordering, even if a category +load triggers a new loadable class </span></span><br><span class="line"><span class="comment">* and a new loadable category attached to that class. </span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Locking: loadMethodLock must be held by the caller </span></span><br><span class="line"><span class="comment">*   All other locks must not be held.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">void</span> call_load_methods(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> loading = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">bool</span> more_categories;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-entrant calls do nothing; the outermost call will finish the job.</span></span><br><span class="line">    <span class="keyword">if</span> (loading) <span class="keyword">return</span>;</span><br><span class="line">    loading = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *pool = objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//  1.重复调用class +loads，直到没有其他类</span></span><br><span class="line">        <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            call_class_loads(); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. Call category +loads ONCE</span></span><br><span class="line">        more_categories = call_category_loads();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. Run more +loads if there are classes OR more untried categories</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories);</span><br><span class="line"></span><br><span class="line">    objc_autoreleasePoolPop(pool);</span><br><span class="line"></span><br><span class="line">    loading = <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* call_class_loads</span></span><br><span class="line"><span class="comment">* Call all pending class +load methods.</span></span><br><span class="line"><span class="comment">* If new classes become loadable, +load is NOT called for them.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Called only by call_load_methods().</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> call_class_loads(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ...................</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Call all +loads for the detached list.</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123;</span><br><span class="line">        Class cls = classes[i].cls;</span><br><span class="line">        <span class="comment">// typedef void(*load_method_t)(id, SEL); 函数指针</span></span><br><span class="line">        load_method_t load_method = (load_method_t)classes[i].method;</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (PrintLoading) &#123;</span><br><span class="line">            _objc_inform(<span class="string">&quot;LOAD: +[%s load]\n&quot;</span>, cls-&gt;nameForLogging());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用函数</span></span><br><span class="line">        (*load_method)(cls, <span class="keyword">@selector</span>(load));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Destroy the detached list.</span></span><br><span class="line">    <span class="keyword">if</span> (classes) free(classes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* call_category_loads</span></span><br><span class="line"><span class="comment">* Call some pending category +load methods.</span></span><br><span class="line"><span class="comment">* The parent class of the +load-implementing categories has all of </span></span><br><span class="line"><span class="comment">*   its categories attached, in case some are lazily waiting for +initalize.</span></span><br><span class="line"><span class="comment">* Don&#x27;t call +load unless the parent class is connected.</span></span><br><span class="line"><span class="comment">* If new categories become loadable, +load is NOT called, and they </span></span><br><span class="line"><span class="comment">*   are added to the end of the loadable list, and we return TRUE.</span></span><br><span class="line"><span class="comment">* Return FALSE if no new categories became loadable.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Called only by call_load_methods().</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> call_category_loads(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ...................</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call all +loads for the detached list.</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123;</span><br><span class="line">        Category cat = cats[i].cat;</span><br><span class="line">        <span class="comment">// 直接找到load函数指针</span></span><br><span class="line">        <span class="comment">// typedef void(*load_method_t)(id, SEL); 函数指针</span></span><br><span class="line">        load_method_t load_method = (load_method_t)cats[i].method;</span><br><span class="line">        Class cls;</span><br><span class="line">        <span class="keyword">if</span> (!cat) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        cls = _category_getClass(cat);</span><br><span class="line">        <span class="keyword">if</span> (cls  &amp;&amp;  cls-&gt;isLoadable()) &#123;</span><br><span class="line">           ...................</span><br><span class="line">            <span class="comment">// 调用load函数</span></span><br><span class="line">            (*load_method)(cls, <span class="keyword">@selector</span>(load));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     ...................</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><ul><li><code>call_class_loads();</code>  </li><li><code>call_category_loads(); </code>  </li><li>从这两处可以看出，先调用类的<code>load</code>方法，再调用分类的<code>load</code>方法</li></ul></blockquote><blockquote><ul><li><code>load_method_t load_method = (load_method_t)cats[i].method;</code> </li><li><code>(*load_method)(cls, @selector(load));</code> </li><li>通过这两句代码可以看出，<code>load</code>方法是直接找到<code>load函数(方法)</code> 的指针，通过指针调用的<code>load函数</code>，不是通过<code>OBJC</code>的消息机制</li></ul></blockquote><blockquote><ul><li><code>+load</code>方法会在<code>runtime</code>加载类、分类时调用，每个类、分类的<code>+load</code>，在程序运行过程中只调用一次</li></ul></blockquote><h5><span id="load-diao-yong-shun-xu">load调用顺序</span><a href="#load-diao-yong-shun-xu" class="header-anchor">#</a></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_load_methods</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ....................</span><br><span class="line">    <span class="keyword">void</span> *pool = objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//  1.重复调用class +loads，直到没有其他类</span></span><br><span class="line">        <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 先调用类</span></span><br><span class="line">            call_class_loads(); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. Call category +loads ONCE （再调用分类）</span></span><br><span class="line">        more_categories = call_category_loads();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. Run more +loads if there are classes OR more untried categories</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories);</span><br><span class="line"></span><br><span class="line">    objc_autoreleasePoolPop(pool);</span><br><span class="line"></span><br><span class="line">    loading = NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare_load_methods</span><span class="params">(<span class="keyword">const</span> headerType *mhdr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    .........</span><br><span class="line">    <span class="keyword">classref_t</span> <span class="keyword">const</span> *classlist = </span><br><span class="line">        _getObjc2NonlazyClassList(mhdr, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">// 按照编译顺序，将类的数据加进去</span></span><br><span class="line">        schedule_class_load(remapClass(classlist[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...........</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* prepare_load_methods</span></span><br><span class="line"><span class="comment">* Schedule +load for classes in this image, any un-+load-ed </span></span><br><span class="line"><span class="comment">* superclasses in other images, and any categories in this image.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="comment">// Recursively schedule +load for cls and any un-+load-ed superclasses.</span></span><br><span class="line"><span class="comment">// cls must already be connected.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">schedule_class_load</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   ..........</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure superclass-first ordering(递归调用,始终先添加父类方法，父类都放入后，开始放入子类对象)</span></span><br><span class="line">    schedule_class_load(cls-&gt;getSuperclass());</span><br><span class="line">    <span class="comment">// 将cls添加到loadable_classes数组的最后面</span></span><br><span class="line">    add_class_to_loadable_list(cls);</span><br><span class="line">    cls-&gt;setInfo(RW_LOADED); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li><code>schedule_class_load(cls-&gt;getSuperclass());</code><br>通过这里可以看出是先调用父类的load方法，再调用子类的load方法</li></ul></blockquote><ul><li><p>先调用类的<code>+load</code></p><ul><li>按照编译先后顺序调用（先编译，先调用）</li><li>调用子类的<code>+load</code>之前会先调用父类的<code>+load</code></li></ul></li><li><p>再调用分类的<code>+load</code></p><ul><li>按照编译先后顺序调用（先编译，先调用）</li></ul></li></ul><h4><span id="initialize-chu-shi-hua">+ initialize (初始化)</span><a href="#initialize-chu-shi-hua" class="header-anchor">#</a></h4><p>源码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* class_initialize.  Send the &#x27;+initialize&#x27; message on demand to any</span></span><br><span class="line"><span class="comment">* uninitialized class. Force initialization of superclasses first.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initializeNonMetaClass</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/****************优先调用父类的initialize方法**********************/</span></span><br><span class="line">    <span class="comment">// Make sure super is done initializing BEFORE beginning to initialize cls.</span></span><br><span class="line">    <span class="comment">// See note about deadlock above.</span></span><br><span class="line">    supercls = cls-&gt;getSuperclass();</span><br><span class="line">    <span class="keyword">if</span> (supercls  &amp;&amp;  !supercls-&gt;isInitialized()) &#123;</span><br><span class="line">        <span class="comment">// 递归</span></span><br><span class="line">        initializeNonMetaClass(supercls);</span><br><span class="line">    &#125;</span><br><span class="line">        @<span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">            ...................调用initialize方法.....................</span></span><br><span class="line"><span class="comment">        **********************************************************************/</span></span><br><span class="line">            callInitialize(cls);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (PrintInitializing) &#123;</span><br><span class="line">                _objc_inform(<span class="string">&quot;INITIALIZE: thread %p: finished +[%s initialize]&quot;</span>,</span><br><span class="line">                             objc_thread_self(), cls-&gt;nameForLogging());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callInitialize</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ((<span class="keyword">void</span>(*)(Class, SEL))objc_msgSend)(cls, @selector(initialize));</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li><p> <code>initializeNonMetaClass(supercls);</code><br>先调用父类的<code>initialize</code>方法,同时这里进行了判断</p></li><li><p><code>if (supercls  &amp;&amp;  !supercls-&gt;isInitialized()) &#123;</code></p></li><li><p>如果父类已经调用过<code>initialize</code>，不会重复调用</p></li><li><p>如果两个类，是同一个父类，并且这两个类的都没有实现<code>initialize</code>，父类的<code>initialize</code>会实现两遍（<code>父类的initialize可能会调用多次</code>），因为<code>initialize</code>是通过<code>OBJC</code>的消息机制调用的</p></li><li><p>如果类A自己没有实现<code>initialize</code>，但是父类实现了<code>initialize</code>，父类的<code>initialize</code>会调用两次，因为<code>initialize</code>是通过<code>OBJC</code>的消息机制调用的</p></li></ul></blockquote><blockquote><ul><li> <code>((void(*)(Class, SEL))objc_msgSend)(cls, @selector(initialize));</code><br>说明<code>initialize</code> 是走的<code>OBJC</code>的消息发送机制</li></ul></blockquote><blockquote><ul><li><code>+initialize</code>方法会在类第一次接收到消息时调用</li></ul></blockquote><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4d36fd79f1a4444a12348e93b1a21a7~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-03-15 上午11.32.56.png"></p><p><strong><code>+initialize</code>和<code>+load</code>的很大区别是，<code>+initialize</code>是通过<code>objc_msgSend</code>进行调用的，所以有以下特点</strong></p><ul><li>如果子类没有实现<code>+initialize</code>，会调用父类的<code>+initialize</code></li><li>如果分类实现了<code>+initialize</code>，就覆盖类本身的<code>+initialize</code>调用 </li></ul><p><strong><code>+initialize</code>和<code>+load</code>的区别</strong></p><p>1.调用方式</p><ul><li>load是根据函数地址直接调用</li><li>initialize是通过objc_msgSend调用</li></ul><p>2.调用时刻</p><ul><li>load是runtime加载类、分类的时候调用（只会调用1次）</li><li>initialize是类第一次接收到消息的时候调用，每一个类只会initialize一次（父类的initialize方法可能会被调用多次）</li></ul><p>load、initialize的调用顺序？</p><p>1.load</p><p>1&gt; 先调用类的load</p><p>a) 先编译的类，优先调用load</p><p>b) 调用子类的load之前，会先调用父类的load</p><p>2&gt; 再调用分类的load</p><p>a) 先编译的分类，优先调用load</p><p>2.initialize</p><p>1&gt; 先初始化父类</p><p>2&gt; 再初始化子类（可能最终调用的是父类的initialize方法）</p><blockquote><p> 通常情况下两者都是只实现一次，不会重复实现。但是不排除重复实现的可能，譬如误操作直接调用这种，建议使用的时候加上<code>dispatch_once</code> 来使用</p></blockquote><h4><span id="guan-lian-dui-xiang-gei-fen-lei-tian-jia-shu-xing">关联对象（给分类添加属性）</span><a href="#guan-lian-dui-xiang-gei-fen-lei-tian-jia-shu-xing" class="header-anchor">#</a></h4><p><strong>在类中声明一个属性，会做三件事情</strong></p><blockquote><ol><li>生成一个成员变量</li><li>生成get和set方法的声明</li><li>实现get和set方法的实现</li></ol></blockquote><p><strong>在分类中写一个属性</strong></p><blockquote><p>只会自动生成<code>get</code>和<code>set</code>方法的<code>声明</code>，不会生成方法实现，不会生成成员变量</p></blockquote><p><strong>默认情况下，因为分类底层结构的限制，不能添加成员变量到分类中。但可以通过关联对象来间接实现</strong></p><blockquote><p>对比看的话类的结构中，有成员变量列表<code>ivars</code>(只读)，用来存储成员变量，通过关联对象添加的成员变量，并不是放到类的<code>ivars</code>中</p></blockquote><ul><li><p>类的结构：<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fca529bcb6c043b4b23050c5292b169e~tplv-k3u1fbpfcp-watermark.image" alt="01-OC语法.png"></p></li><li><p>分类的结构</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">category_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">// 类名</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">class_t</span> *<span class="title">cls</span>;</span> <span class="comment">//</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">method_list_t</span> *<span class="title">instance_methods</span>;</span> <span class="comment">// 对象方法</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">method_list_t</span> *<span class="title">class_methods</span>;</span>   <span class="comment">//  类方法</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span>   <span class="comment">//  协议</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">prop_list_t</span> *<span class="title">properties</span>;</span>   <span class="comment">//  属性</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p><strong>关联对象提供了以下API</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 添加关联对象</span><br><span class="line">void objc_setAssociatedObject(id object, const void * key,</span><br><span class="line">                                id value, objc_AssociationPolicy policy)</span><br><span class="line"></span><br><span class="line">2. 获得关联对象</span><br><span class="line">id objc_getAssociatedObject(id object, const void * key)</span><br><span class="line"></span><br><span class="line">3. 移除所有的关联对象</span><br><span class="line">void objc_removeAssociatedObjects(id object)</span><br></pre></td></tr></table></figure><p><strong><code>const</code>修饰的是全局变量，外部可以通过<code>extern</code>关键字进行访问，给全局变量加上<code>static</code>意味着只有当前文件内部可以访问</strong> </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h </span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">char</span> outKey（编译成功）</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">char</span> privateKey （编译报错）</span><br><span class="line"></span><br><span class="line"><span class="comment">// .m</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> outKey (外部可以通过<span class="keyword">extern</span>访问)</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> privateKey (因为有<span class="keyword">static</span>，外部无法访问)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5><span id="key-de-chang-jian-yong-fa">key的常见用法</span><a href="#key-de-chang-jian-yong-fa" class="header-anchor">#</a></h5><ul><li><p>使用变量地址值，赋值比较啰嗦，切占8个字节(指针变量)</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *MyKey = &amp;MyKey;</span><br><span class="line">objc_setAssociatedObject(obj, MyKey, value, OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><br><span class="line">objc_getAssociatedObject(obj, MyKey)</span><br></pre></td></tr></table></figure></li><li><p>还是使用变量地址，但是只占一个字节（char变量）</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> MyKey;</span><br><span class="line">objc_setAssociatedObject(obj, &amp;MyKey, value, OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><br><span class="line">objc_getAssociatedObject(obj, &amp;MyKey)</span><br></pre></td></tr></table></figure></li><li><p>使用属性名作为key(@”property”在常量区，内存地址一致)</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objc_setAssociatedObject(obj, <span class="string">@&quot;property&quot;</span>, value, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">objc_getAssociatedObject(obj, <span class="string">@&quot;property&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>使用get方法的@selecor作为key</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objc_setAssociatedObject(obj, <span class="keyword">@selector</span>(<span class="keyword">getter</span>), value, OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><br><span class="line">objc_getAssociatedObject(obj, _cmd) <span class="comment">// _cmd == @selector(getter)</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>API</strong> </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Sets an associated value for a given object using a given key and association policy.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param object 关联对象（一般是self）</span></span><br><span class="line"><span class="comment"> * @param key 关联的关键词</span></span><br><span class="line"><span class="comment"> * @param value 关联的数值，传nil移除关联对象</span></span><br><span class="line"><span class="comment"> * @param policy 关联策略</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @see objc_setAssociatedObject</span></span><br><span class="line"><span class="comment"> * @see objc_removeAssociatedObjects</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">OBJC_EXPORT <span class="keyword">void</span></span><br><span class="line">objc_setAssociatedObject(<span class="keyword">id</span> _Nonnull object, <span class="keyword">const</span> <span class="keyword">void</span> * _Nonnull key,</span><br><span class="line">                         <span class="keyword">id</span> _Nullable value, objc_AssociationPolicy policy)</span><br><span class="line">    OBJC_AVAILABLE(<span class="number">10.6</span>, <span class="number">3.1</span>, <span class="number">9.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Returns the value associated with a given object for a given key.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param object 关联对象</span></span><br><span class="line"><span class="comment"> * @param key 关联的关键词</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return The value associated with the key \e key for \e object.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @see objc_setAssociatedObject</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">OBJC_EXPORT <span class="keyword">id</span> _Nullable</span><br><span class="line">objc_getAssociatedObject(<span class="keyword">id</span> _Nonnull object, <span class="keyword">const</span> <span class="keyword">void</span> * _Nonnull key)</span><br><span class="line">    OBJC_AVAILABLE(<span class="number">10.6</span>, <span class="number">3.1</span>, <span class="number">9.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>);</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p><strong>实际使用</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(name), name, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 隐式参数</span></span><br><span class="line">    <span class="comment">// _cmd == @selector(name)</span></span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, _cmd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>objc_AssociationPolicy (关联策略)</strong></p><p>没有<code>weak</code>效果，使用要注意，离开赋值范围要手动设置<code>nil</code></p><table><thead><tr><th>objc_AssociationPolicy</th><th>对应的修饰符</th></tr></thead><tbody><tr><td><code>OBJC_ASSOCIATION_ASSIGN </code></td><td><code>assign</code></td></tr><tr><td><code>OBJC_ASSOCIATION_RETAIN_NONATOMIC</code></td><td><code>strong, nonatomic</code></td></tr><tr><td><code>OBJC_ASSOCIATION_COPY_NONATOMIC</code></td><td><code>copy, nonatomic</code></td></tr><tr><td><code>OBJC_ASSOCIATION_RETAIN</code></td><td><code>strong, atomic</code></td></tr><tr><td><code>OBJC_ASSOCIATION_COPY</code></td><td><code>copy, atomic</code></td></tr></tbody></table><h5><span id="guan-lian-dui-xiang-yuan-li-di-ceng-shi-xian">关联对象原理(底层实现)</span><a href="#guan-lian-dui-xiang-yuan-li-di-ceng-shi-xian" class="header-anchor">#</a></h5><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4eba97fea4f64af4888280a34b819235~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-03-15 下午3.26.30.png"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c1bbf14d3bd4c62b0e127ab37d16cac~tplv-k3u1fbpfcp-zoom-1.image" alt="关联对象原理.png"></p><blockquote><p>全局有一个<code>AssociationsManager</code>，里面保存一个成员变量</p><p><code>AssociationsHashMap *map&#123;关联对象(object): ObjectAssociationMap&#125;</code></p><p>根据<code>关联对象</code>，可以得到一个</p><p><code>AssociationMap &#123;key:ObjcAssociation&#125;对象</code>，</p><p><code>ObjcAssociation</code>有两个属性 {<code>value</code>,<code>policy</code>}</p></blockquote><p>关联对象不会增加<code>成员变量</code>，不能通过<code>person -&gt; age</code> 形式进行访问</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4&gt;&lt;span id=&quot;category&quot;&gt;category&lt;/span&gt;&lt;a href=&quot;#category&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;&lt;code&gt;category&lt;/code&gt;中的方法是通过&lt;code&gt;runtime&lt;/cod</summary>
      
    
    
    
    
    <category term="底层" scheme="http://example.com/tags/%E5%BA%95%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>底层五：Runtime</title>
    <link href="http://example.com/2021/03/08/%E5%BA%95%E5%B1%82%E4%BA%94%EF%BC%9ARuntime/"/>
    <id>http://example.com/2021/03/08/%E5%BA%95%E5%B1%82%E4%BA%94%EF%BC%9ARuntime/</id>
    <published>2021-03-08T03:36:07.000Z</published>
    <updated>2021-03-22T09:18:35.833Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="oc-de-xiao-xi-ji-zhi">OC 的消息机制</span><a href="#oc-de-xiao-xi-ji-zhi" class="header-anchor">#</a></h2><blockquote><p><code>OC 的消息机制</code> ： OC中的方法调用其实都是转成了<code>objc_msgSend</code>函数的调用，给<code>receiver（方法调用者）</code>发送了一条<code>消息（selector方法名）</code></p></blockquote><blockquote><p><code>Objective-C</code>是一门<code>动态性</code>比较强的编程语言，跟C、C++等语言有着很大的不同</p></blockquote><blockquote><p><code>Runtime API</code>提供的接口基本都是<code>C语言</code>的，源码由<code>C\C++\汇编语言</code>编写</p></blockquote><h3><span id="isa-xiang-jie">isa详解</span><a href="#isa-xiang-jie" class="header-anchor">#</a></h3><h4><span id="gong-yong-ti-union">共用体(union)</span><a href="#gong-yong-ti-union" class="header-anchor">#</a></h4><p><code>定义：</code>所有参数占用同一块内存</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> year </span><br><span class="line">    <span class="keyword">int</span> month</span><br><span class="line">    <span class="keyword">int</span> day </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 其中year 、 month、day分别占用自己的内存，每个占用4个字节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> year </span><br><span class="line">    <span class="keyword">int</span> month</span><br><span class="line">    <span class="keyword">int</span> day </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 其中year 、 month、day是同一块内存，一共占用4个字节</span></span><br></pre></td></tr></table></figure><p> 定义一个共用体，并使用 </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">char</span> bits; <span class="comment">// 一个字节</span></span><br><span class="line">        <span class="comment">// 结构体仅仅是增加了可读性，完全可以删掉，结构体也只占一位,位置完全有Mask决定</span></span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            <span class="keyword">char</span> tall : <span class="number">1</span>; <span class="comment">// 只占一位，在最右边</span></span><br><span class="line">            <span class="keyword">char</span> rich : <span class="number">1</span>; <span class="comment">// 只占一位</span></span><br><span class="line">            <span class="keyword">char</span> handsome : <span class="number">1</span>; <span class="comment">// 只占一位</span></span><br><span class="line">            <span class="keyword">char</span> thin : <span class="number">1</span>; <span class="comment">// 只占一位, 在最左边</span></span><br><span class="line">            <span class="comment">// 0000 thin / handsome / rich / tall</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; _tallRichHandsome;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bits 和 结构体，都是一个字节，使用同样的一块一字节内容，相互影响，但是因为只是用bits，所以struct只是为了可读性，没有作用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// `1 &lt;&lt; 0` 表示`1左移0位` 即 `0b 0000 0001` </span></span><br><span class="line"><span class="comment">// `mask`表示掩码，执行`按位与`操作</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MJTallMask (1&lt;&lt;0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MJRichMask (1&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MJHandsomeMask (1&lt;&lt;2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MJThinMask (1&lt;&lt;3)</span></span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MJPerson</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setTall:(<span class="built_in">BOOL</span>)tall;</span><br><span class="line">- (<span class="keyword">void</span>)setRich:(<span class="built_in">BOOL</span>)rich;</span><br><span class="line">- (<span class="keyword">void</span>)setHandsome:(<span class="built_in">BOOL</span>)handsome;</span><br><span class="line">- (<span class="keyword">void</span>)setThin:(<span class="built_in">BOOL</span>)thin;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isTall;</span><br><span class="line">- (<span class="built_in">BOOL</span>)isRich;</span><br><span class="line">- (<span class="built_in">BOOL</span>)isHandsome;</span><br><span class="line">- (<span class="built_in">BOOL</span>)isThin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;MJPerson.h&quot;</span></span></span><br><span class="line"><span class="comment">// `mask`表示掩码 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MJTallMask (1&lt;&lt;0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MJRichMask (1&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MJHandsomeMask (1&lt;&lt;2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MJThinMask (1&lt;&lt;3)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MJPerson</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">char</span> bits;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            <span class="keyword">char</span> tall : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">char</span> rich : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">char</span> handsome : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">char</span> thin : <span class="number">1</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; _tallRichHandsome;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MJPerson</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setTall:(<span class="built_in">BOOL</span>)tall</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tall) &#123;</span><br><span class="line">        _tallRichHandsome.bits |= MJTallMask;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 按位取反</span></span><br><span class="line">        _tallRichHandsome.bits &amp;= ~MJTallMask;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isTall</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 两个&quot;!&quot;，将类型强转为BOOL类型</span></span><br><span class="line">    <span class="keyword">return</span> !!(_tallRichHandsome.bits &amp; MJTallMask);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setRich:(<span class="built_in">BOOL</span>)rich</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (rich) &#123;</span><br><span class="line">        _tallRichHandsome.bits |= MJRichMask;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _tallRichHandsome.bits &amp;= ~MJRichMask;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isRich</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 两个&quot;!&quot;，将类型强转为BOOL类型</span></span><br><span class="line">    <span class="keyword">return</span> !!(_tallRichHandsome.bits &amp; MJRichMask);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setHandsome:(<span class="built_in">BOOL</span>)handsome</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (handsome) &#123;</span><br><span class="line">        _tallRichHandsome.bits |= MJHandsomeMask;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _tallRichHandsome.bits &amp;= ~MJHandsomeMask;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isHandsome</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 两个&quot;!&quot;，将类型强转为BOOL类型</span></span><br><span class="line">    <span class="keyword">return</span> !!(_tallRichHandsome.bits &amp; MJHandsomeMask);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setThin:(<span class="built_in">BOOL</span>)thin</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (thin) &#123;</span><br><span class="line">        _tallRichHandsome.bits |= MJThinMask;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _tallRichHandsome.bits &amp;= ~MJThinMask;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isThin</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 两个&quot;!&quot;，将类型强转为BOOL类型</span></span><br><span class="line">    <span class="keyword">return</span> !!(_tallRichHandsome.bits &amp; MJThinMask);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4><span id="isa-ben-zhi">isa本质</span><a href="#isa-ben-zhi" class="header-anchor">#</a></h4><blockquote><p>在<code>arm64</code>架构之前，<code>isa</code>就是一个普通的指针，存储着<code>Class、Meta-Class</code>对象的内存地址</p></blockquote><blockquote><p>从<code>arm64</code>架构开始，对<code>isa</code>进行了优化，变成了一个<code>共用体（union）</code>结构，还使用<code>位域(二进制位)</code>来存储更多的信息</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c9acd43d1594a589da1cb2ad487b419~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-03-18 上午10.33.55.png"></p><p>根据共用体知识，这里的内容全部存储在<code>uintptr_t bits</code>中，结构体只是为了更方便阅读，没有任何作用（可以删掉），共用体后面的数字代表占了<code>多少位</code></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cbb894957aa4bb8b66d040f8bbce6ed~tplv-k3u1fbpfcp-zoom-1.image" alt="屏幕快照 2018-07-18 23.19.09.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ARM64 simulators have a larger address space, so use the ARM64e</span></span><br><span class="line"><span class="comment">// scheme even when simulators build for ARM64-not-e.</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> __has_feature(ptrauth_calls) || TARGET_OS_SIMULATOR(模拟器)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MASK        0x007ffffffffffff8ULL</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MASK        0x0000000ffffffff8ULL</span></span><br></pre></td></tr></table></figure><p>可以根据<code>ISA_MASK</code>，推断出要取出<code>共用体</code>中的33位，用来存储<code>类对象、元类对象</code>的地址</p><blockquote><p><code>nonpointer ：</code></p><p> <code>0</code> 代表普通的指针，存储着<code>Class、Meta-Class对象</code>的内存地址<br> <code>1</code>代表优化过，使用位域存储更多的信息</p></blockquote><hr><blockquote><p><code>has_assoc(has_associatedObject)</code><br>是否有设置过<code>关联对象</code>，如果没有，释放时会更快</p></blockquote><hr><blockquote><p><code>has_cxx_dtor</code><br>是否有<code>C++</code>的<code>析构函数</code>（.cxx_destruct），如果没有，释放时会更快</p><hr><p><code>shiftcls</code><br>存储着<code>Class、Meta-Class对象</code>的<code>内存地址</code>信息</p><hr><p><code>magic</code><br>用于在调试时分辨对象是否未完成<code>初始化</code></p><hr><p><code>weakly_referenced</code><br>是否有被<code>弱引用</code>指向过，如果没有，释放时会更快</p><hr><p><code>deallocating</code><br>对象是否正在释放</p><hr><p><code>extra_rc</code>（extra_retainCount）<br>里面存储的值是引用计数器的数值减去1（如果引用计数器存储的是10，这里存的就是9）</p><hr><p><code>has_sidetable_rc</code><br>引用计数器是否过大无法存储在<code>isa</code>中<br>如果为1，那么引用计数会存储在一个叫<code>SideTable</code>的类的属性中</p></blockquote><h3><span id="class-de-jie-gou-lei-dui-xiang-he-yuan-lei-dui-xiang-de-jie-gou-ti">Class的结构(类对象和元类对象的结构体)</span><a href="#class-de-jie-gou-lei-dui-xiang-he-yuan-lei-dui-xiang-de-jie-gou-ti" class="header-anchor">#</a></h3><p><code>成员变量</code>和<code>属性</code>的定义</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interfacePerson :<span class="built_in">NSObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定义成员变量</span></span><br><span class="line">    int_age;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 属性</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">NSString</span>  *name;</span><br></pre></td></tr></table></figure><p><code>Class 的结构</code></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb982108f3c44aa2aaad19fac8681ece~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-03-18 上午10.34.50.png"></p><blockquote><p>这张图上的<code>Class_rw_t</code> 中</p><p><code>xxx_list_t &lt;method_list_t、property_list_t、protocol_list_t&gt;</code></p><p>在源码中可以看到是对应的数组的形式</p><p><code>xxx_array_t &lt;method_array_t、property_array_t、protocol_array_t&gt;</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_rw_t</span> &#123;</span></span><br><span class="line">    <span class="comment">// Be warned that Symbolication knows the layout of this structure.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint32_t</span> version;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *ro;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">method_array_t</span> methods;</span><br><span class="line">    <span class="keyword">property_array_t</span> properties;</span><br><span class="line">    <span class="keyword">protocol_array_t</span> protocols;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>class_rw_t的结构</code></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d062afe4c7a74a4f9d2e7de8ed14817e~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-03-18 上午10.35.14.png"></p><p><code>class_ro_t的结构</code><br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b28b1727c8054a7aa2ef7f39fbc38600~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-03-18 上午10.35.32.png"></p><ul><li><p><code>class_rw_t</code>里面的<code>methods</code>、<code>properties</code>、<code>protocols</code>是二维数组，是<code>可读可写</code>的，包含了类的初始内容、分类的内容。<code>class_ro_t</code>的内容会被放到方法实现类数组<code>methods</code>的栈底，<code>分类</code>的方法会加载到栈顶的位置</p></li><li><p><code>class_ro_t</code>里面的<code>baseMethodList</code>、<code>baseProtocols</code>、<code>ivars</code>、<code>baseProperties</code>是一维数组，是<code>只读</code>的，包含了类的初始内容</p></li></ul><p><code>method_t</code>是对方法\函数的封装</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12bb663991f046c198f707ef459b894a~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-03-18 上午10.36.21.png"></p><p><code>IMP</code>代表函数的具体实现</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/337859cd2b884a0baefc85e0ae658c5e~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-03-18 上午10.36.47.png"></p><p><code>SEL</code>代表方法名（就是个名字），一般叫做选择器</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37655a7808054f448eb2ec9fa991264b~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-03-18 上午10.37.13.png"></p><blockquote><ul><li>可以通过<code>@selector()</code>和<code>sel_registerName()</code>获得</li><li>可以通过<code>sel_getName()</code>和<code>NSStringFromSelector()</code>转成字符串</li><li>不同类中相同名字的方法，所对应的方法选择器是相同的 </li></ul></blockquote><p><code>type</code>包含了函数返回值、参数编码的字符串(<code>iOS</code>中提供了一个叫做<code>@encode</code>的指令，可以将具体的类型表示成字符串编码)</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b74a0ce1643a4ef8aec0434655ac7398~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-03-18 上午10.37.38.png"></p><h3><span id="fang-fa-huan-cun">方法缓存</span><a href="#fang-fa-huan-cun" class="header-anchor">#</a></h3><blockquote><p><code>[person test]</code>相当于给<code>person</code>发一个<code>test</code>消息，<code>person</code>去对应的<code>类对象</code>的<code>method_array_t* methods</code> 去遍历查找方法，但是因为<code>methods</code>是一个二维数据，如果没找到还要通过<code>superClass</code>指针去父类里面找，遍历查找的效率还是比较底的</p></blockquote><p><code>Class</code>内部结构中有个方法缓存<code>cache_t</code>，用<code>散列表（哈希表）&lt;底层是个动态数组&gt;</code>来缓存曾经调用过的方法，可以提高方法的查找速度</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/761b36d09a6741af8f34f74400c9387f~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-03-18 上午10.38.03.png"></p><ul><li><p><code>散列表</code> 使用<code>函数名（SEL）</code>和<code>mask_t _mask(散列表长度减一)</code> 按位<code>与</code>的方式生成<code>key</code>，如果<code>key</code>相同了，直接将<code>key</code>数值减一，存到散列表中，取出过程中是先去取数据，如果发现取出的数据跟当前的<code>key</code>不一致，也要减一，如果减到零，就变成<code>_mask</code>(散列表最大值),继续减一</p></li><li><p>达到快速查找方法的实现。以空间换取时间</p></li><li><p>一旦动态数组扩容，会清空里面的数据</p></li></ul><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35bd9cc86acd4efeaa9c1e50c23d6c2c~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-03-18 上午10.38.30.png"></p><h3><span id="objc-msgsend-zhi-xing-liu-cheng">objc_msgSend执行流程</span><a href="#objc-msgsend-zhi-xing-liu-cheng" class="header-anchor">#</a></h3><p>OC中的<code>方法调用</code>(<code>消息机制</code>)，其实都是转换为<code>objc_msgSend</code>函数的调用, 就是给方法<code>调用者(reciver)</code>发送消息</p><p><code>objc_messageSend</code> 三大阶段</p><blockquote><p>1.消息发送</p><p>2.动态方法解析</p><p>3.消息转发</p></blockquote><p><strong>objc_msgSend执行流程 – 源码跟读</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bcbdbc6c03d54ea59292b22cc8e5af49~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-03-18 上午10.39.21.png"></p><p><strong>objc_msgSend执行流程01-<code>消息发送</code></strong></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b66ea94132d64ca7b424bf409608e9a0~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-03-18 上午10.39.48.png"></p><p><strong>objc_msgSend执行流程02-<code>动态方法解析</code></strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/024506283ae4459ebd554450f2bd1f5f~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-03-18 上午10.40.00.png"><br><strong>动态添加方法</strong></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37787f94266c4669ad5b22e21beb5ba9~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-03-18 上午10.40.31.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)resolveClassMethod:(SEL)sel &#123;</span><br><span class="line">    if (sel &#x3D;&#x3D; @selector(test)) &#123;</span><br><span class="line">        &#x2F;&#x2F; 在元类方法列表里面存放的类方法，如果找不到，会转向最后的父类查找对象方法</span><br><span class="line">        &#x2F;&#x2F; Method  method &#x3D; class_getInstanceMethod(self, @selector(other));</span><br><span class="line">        </span><br><span class="line">        Method  method &#x3D; class_getClassMethod(self, @selector(other));</span><br><span class="line">        </span><br><span class="line">        class_addMethod(object_getClass(self),</span><br><span class="line">                        sel,</span><br><span class="line">                        method_getImplementation(method),</span><br><span class="line">                        method_getTypeEncoding(method));</span><br><span class="line">        &#x2F;&#x2F; 从源码可以看出， 这里返回YES或者NO都可以</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveClassMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>从源码可以看出，在调用完动态方法解析后，会调用goto函数，再次进行<code>消息发送</code>，因为已经在类中添加了方法，所以可以在类对象（或元类对象中找到方法）</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class_addMethod(object_getClass(<span class="keyword">self</span>),</span><br><span class="line">                      sel,</span><br><span class="line">                      method_getImplementation(method),</span><br><span class="line">                      method_getTypeEncoding(method));</span><br></pre></td></tr></table></figure><p><strong>objc_msgSend的执行流程03-<code>消息转发</code></strong></p><blockquote><p>当前类无法处理消息，就将消息转发给其他类进行处理</p></blockquote><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12906464486b4acb80cef3d088ba6667~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-03-18 上午10.41.05.png"></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(test)) &#123;</span><br><span class="line">        <span class="comment">// objc_msgSend([[MJCat alloc] init], aSelector)</span></span><br><span class="line">        <span class="keyword">return</span> [[MJCat alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法签名：返回值类型、参数类型</span></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(test:name:)) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:<span class="string">&quot;v@:&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NSInvocation封装了一个方法调用，包括：方法调用者、方法名、方法参数</span></span><br><span class="line"><span class="comment">//    anInvocation.target 方法调用者</span></span><br><span class="line"><span class="comment">//    anInvocation.selector 方法名</span></span><br><span class="line"><span class="comment">//    [anInvocation getArgument:NULL atIndex:0]</span></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//    anInvocation.target = [[MJCat alloc] init];</span></span><br><span class="line"><span class="comment">//    [anInvocation invoke];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//[anInvocation invokeWithTarget:[[MJCat alloc] init]];</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,<span class="built_in">NSStringFromSelector</span>(anInvocation.selector));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 有返回值的处理</span></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(test:)) &#123;</span><br><span class="line"><span class="comment">//        return [NSMethodSignature signatureWithObjCTypes:&quot;v20@0:8i16&quot;];</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:<span class="string">&quot;i@:i&quot;</span>];</span><br><span class="line"><span class="comment">//        return [[[MJCat alloc] init] methodSignatureForSelector:aSelector];</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 参数顺序：receiver、selector、other arguments</span></span><br><span class="line"><span class="comment">//    int age;</span></span><br><span class="line"><span class="comment">//    [anInvocation getArgument:&amp;age atIndex:2];</span></span><br><span class="line"><span class="comment">//    NSLog(@&quot;%d&quot;, age + 10);</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// anInvocation.target == [[MJCat alloc] init]</span></span><br><span class="line">    <span class="comment">// anInvocation.selector == test:</span></span><br><span class="line">    <span class="comment">// anInvocation的参数：15</span></span><br><span class="line">    <span class="comment">// [[[MJCat alloc] init] test:15]</span></span><br><span class="line">    </span><br><span class="line">    [anInvocation invokeWithTarget:[[MJCat alloc] init]];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    [anInvocation getReturnValue:&amp;ret];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>, ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="super-de-ben-zhi">super的本质</span><a href="#super-de-ben-zhi" class="header-anchor">#</a></h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;Student.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;[self class] = %@&quot;</span>, [<span class="keyword">self</span> <span class="keyword">class</span>]); <span class="comment">// Student</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;[self superclass] = %@&quot;</span>, [<span class="keyword">self</span> superclass]); <span class="comment">// Person</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;--------------------------------&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// objc_msgSendSuper(&#123;self, [MJPerson class]&#125;, @selector(class));</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;[super class] = %@&quot;</span>, [<span class="keyword">super</span> <span class="keyword">class</span>]); <span class="comment">// Student</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;[super superclass] = %@&quot;</span>, [<span class="keyword">super</span> superclass]); <span class="comment">// Person</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><blockquote><ol><li>将<code>Student</code>中的方法 <code>[super run]</code> 转换成<code>CPP</code>代码，来探究<code>super</code>的本质</li></ol></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转换前</span></span><br><span class="line">- (<span class="keyword">void</span>)run</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> run];   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换后</span></span><br><span class="line">    objc_msgSendSuper (</span><br><span class="line">                        (__rw_objc_super)&#123;</span><br><span class="line">                                <span class="keyword">self</span>,</span><br><span class="line">                            class_getSuperclass(objc_getClass(<span class="string">&quot;Student&quot;</span>))</span><br><span class="line">                        &#125;, <span class="keyword">@selector</span>(run)</span><br><span class="line">                    );</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>2.将转换后的代码进行抽取、查找得出如下代码</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">rw_objc_super</span> <span class="title">arg</span> =</span> &#123;</span><br><span class="line">    self,</span><br><span class="line">    class_getSuperclass(objc_getClass(<span class="string">&quot;Student&quot;</span>)) <span class="comment">// 根据函数可以看出是Peron</span></span><br><span class="line">&#125;</span><br><span class="line">objc_msgSendSuper(arg, @selector(run))</span><br></pre></td></tr></table></figure><blockquote><p>3.查找 <code>objc_super</code> 的源码</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_super</span> &#123;</span></span><br><span class="line">    __unsafe_unretained _Nonnull id receiver; <span class="comment">// 消息接受者</span></span><br><span class="line">    __unsafe_unretained _Nonnull Class super_class; <span class="comment">// 消息接受者的父类</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><blockquote><p>4.根据上面的代码和源码可以得出<code>[super run ]</code>转换后的代码</p><p><code>objc_msgSendSuper(&#123;self,person&#125;, @selector(run));</code></p></blockquote><blockquote><p>5.查看<code>objc_msgSendSuper</code>的源码，在<code>message.h</code>中，找到如下的注释</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 从父类的方法列表里开始查找方法实现</span><br><span class="line">the superclass at which to start searching for the method implementation.</span><br></pre></td></tr></table></figure><p><strong>结论</strong>：<code>super</code>方法，只是从父类对象开始找出方法实现，但是<code>receiver</code>还是当前类</p><blockquote><p>[super message]的底层实现</p><ul><li>1.消息接收者仍然是子类对象</li><li>2.从父类开始查找方法的实现</li></ul></blockquote><p>回到开始的问题：<code>[super class]</code> 的打印值，就牵扯到<code>class</code>的方法实现，在<code>NSObject.mm</code> 中查看 <code>class</code>、<code>superclass</code>的源码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+ (Class)<span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Class)<span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> object_getClass(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (Class)superclass &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>-&gt;getSuperclass();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Class)superclass &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> <span class="keyword">class</span>]-&gt;getSuperclass();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>结论</strong>：<code>[super class]</code> 打印出来的是<code>recever</code>，也就是<code>student</code></p><h4><span id="iskindofclass-he-ismemberofclass">isKindOfClass 和 isMemberOfClass</span><a href="#iskindofclass-he-ismemberofclass" class="header-anchor">#</a></h4><p>在<code>NSObject.mm</code> 中找到源码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断cls对象，是否是self的元类</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>-&gt;ISA() == cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断cls是否是[self class]</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> <span class="keyword">class</span>] == cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断cls对象，是否是self的元类、或者self的元类的父类</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class tcls = <span class="keyword">self</span>-&gt;ISA(); tcls; tcls = tcls-&gt;getSuperclass()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tcls == cls) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断cls是否是[self class]，或者[self class]的父类</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class tcls = [<span class="keyword">self</span> <span class="keyword">class</span>]; tcls; tcls = tcls-&gt;getSuperclass()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tcls == cls) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="runtime-ji-ben-han-shu">runtime基本函数</span><a href="#runtime-ji-ben-han-shu" class="header-anchor">#</a></h3><h4><span id="api">API</span><a href="#api" class="header-anchor">#</a></h4><h5><span id="lei">类</span><a href="#lei" class="header-anchor">#</a></h5><p>动态创建一个类（参数：父类，类名，额外的内存空间）</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class objc_allocateClassPair(Class superclass, <span class="keyword">const</span> <span class="keyword">char</span> *name, size_t extraBytes)</span><br></pre></td></tr></table></figure><p>注册一个类（要在类注册之前添加成员变量），成员变量在<code>class_ro_t</code>结构体中是只读的，没法在创建完类后动态添加成员变量</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> objc_registerClassPair(Class cls) </span><br></pre></td></tr></table></figure><p>销毁一个类</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> objc_disposeClassPair(Class cls)</span><br></pre></td></tr></table></figure><p>获取isa指向的Class</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class object_getClass(<span class="keyword">id</span> obj)</span><br></pre></td></tr></table></figure><p>设置isa指向的Class</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class object_setClass(<span class="keyword">id</span> obj, Class cls)</span><br></pre></td></tr></table></figure><p>判断一个OC对象是否为Class</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> object_isClass(<span class="keyword">id</span> obj)</span><br></pre></td></tr></table></figure><p>判断一个Class是否为元类</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> class_isMetaClass(Class cls)</span><br></pre></td></tr></table></figure><p>获取父类</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class class_getSuperclass(Class cls)</span><br></pre></td></tr></table></figure><h5><span id="cheng-yuan-bian-liang">成员变量</span><a href="#cheng-yuan-bian-liang" class="header-anchor">#</a></h5><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6d0e8b27f78416da8bf755e0874bc41~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-03-22 下午2.28.18.png"></p><p><code>Ivar *class_copyIvarList(Class cls, unsigned int *outCount)</code> 常用，使用最后要调用<code>free</code>释放</p><h5><span id="shu-xing">属性</span><a href="#shu-xing" class="header-anchor">#</a></h5><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/461069831368408880a92f6d2c139620~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-03-22 下午5.12.47.png"></p><h5><span id="fang-fa">方法</span><a href="#fang-fa" class="header-anchor">#</a></h5><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d725a7c6f6f64a229161b20d3cf053d6~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-03-22 下午5.13.14.png"></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7dff60d2baf340bc974d81cf563556ff~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-03-22 下午5.13.36.png"></p><ol><li><p>查看类的属性、方法、成员变量、协议</p></li><li><p>字典转模型</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">Json</span>)</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)mj_objectWithJson:(<span class="built_in">NSDictionary</span> *)json;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;NSObject+Json.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">Json</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)mj_objectWithJson:(<span class="built_in">NSDictionary</span> *)json</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> obj = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count;</span><br><span class="line">    Ivar *ivars = class_copyIvarList(<span class="keyword">self</span>, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">// 取出i位置的成员变量</span></span><br><span class="line">        Ivar ivar = ivars[i];</span><br><span class="line">        <span class="built_in">NSMutableString</span> *name = [<span class="built_in">NSMutableString</span> stringWithUTF8String:ivar_getName(ivar)];</span><br><span class="line">        [name deleteCharactersInRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, <span class="number">1</span>)];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设值</span></span><br><span class="line">        <span class="keyword">id</span> value = json[name];</span><br><span class="line">        <span class="keyword">if</span> ([name isEqualToString:<span class="string">@&quot;ID&quot;</span>]) &#123;</span><br><span class="line">            value = json[<span class="string">@&quot;id&quot;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        [obj setValue:value forKey:name];</span><br><span class="line">    &#125;</span><br><span class="line">    free(ivars);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>替换方法实现</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;UIControl+Extension.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIControl</span> (<span class="title">Extension</span>)</span></span><br><span class="line"><span class="comment">// 交换按钮点击事件，会调用sendAction:to:forEvent:方法，交换方法实现</span></span><br><span class="line">+ (<span class="keyword">void</span>)load</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// hook：钩子函数</span></span><br><span class="line">    Method method1 = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(sendAction:to:forEvent:));</span><br><span class="line">    Method method2 = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(mj_sendAction:to:forEvent:));</span><br><span class="line">    <span class="comment">// 会清空缓存</span></span><br><span class="line">    method_exchangeImplementations(method1, method2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)mj_sendAction:(SEL)action to:(<span class="keyword">id</span>)target forEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@-%@-%@&quot;</span>, <span class="keyword">self</span>, target, <span class="built_in">NSStringFromSelector</span>(action));</span><br><span class="line">    <span class="comment">// 调用系统原来的实现</span></span><br><span class="line">    [<span class="keyword">self</span> mj_sendAction:action to:target forEvent:event];</span><br><span class="line"><span class="comment">//    if ([self isKindOfClass:[UIButton class]]) &#123;</span></span><br><span class="line"><span class="comment">//        // 拦截了所有按钮的事件</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></li></ol><p>查看 <code>method_exchangeImplementations</code> 的源码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> method_exchangeImplementations(Method m1, Method m2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!m1  ||  !m2) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    mutex_locker_t lock(runtimeLock);</span><br><span class="line"></span><br><span class="line">    IMP imp1 = m1-&gt;imp(<span class="literal">false</span>);</span><br><span class="line">    IMP imp2 = m2-&gt;imp(<span class="literal">false</span>);</span><br><span class="line">    SEL sel1 = m1-&gt;name();</span><br><span class="line">    SEL sel2 = m2-&gt;name();</span><br><span class="line">     <span class="comment">// 交换两个method的imp</span></span><br><span class="line">    m1-&gt;setImp(imp2);</span><br><span class="line">    m2-&gt;setImp(imp1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 冲洗缓存，这个方法会清空缓存</span></span><br><span class="line">    flushCaches(<span class="literal">nil</span>, __func__, [sel1, sel2, imp1, imp2](Class c)&#123;</span><br><span class="line">        <span class="keyword">return</span> c-&gt;cache.shouldFlush(sel1, imp1) || c-&gt;cache.shouldFlush(sel2, imp2);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    adjustCustomFlagsForMethodChange(<span class="literal">nil</span>, m1);</span><br><span class="line">    adjustCustomFlagsForMethodChange(<span class="literal">nil</span>, m2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过源码可以看出<code>method_exchangeImplementations</code>本质是交换两个<code>method</code>中的<code>imp</code></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a74bdf5ed6d47a29c2ce7bc4df2c1b8~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-03-22 下午4.22.58.png"></p><p><code>object_getClass</code>: 本质是获取<code>isa</code>指向的<code>class</code></p><p><code>object_setClass</code>： 设置<code>isa</code>指向的<code>class</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Person *person = [[Person alloc] init];</span><br><span class="line">[person run];</span><br><span class="line">object_setClass(person, [Car <span class="keyword">class</span>]);</span><br><span class="line">[person run];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：可以发现对象的isa指针指向的类对象，被替换掉了</span></span><br><span class="line">-[JXPerson run]</span><br><span class="line">-[Car run]</span><br></pre></td></tr></table></figure><p>交换方法实现</p><p><strong>设置动态数组，添加nil防止崩溃</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;NSMutableArray+Extension.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSMutableArray</span> (<span class="title">Extension</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="comment">// 类簇：NSString、NSArray、NSDictionary，真实类型是其他类型</span></span><br><span class="line">        <span class="comment">//类簇是Foundation框架中广泛使用的设计模式。类簇将一些私有的、具体的子类组合在一个公共的、抽象的超类下面，以这种方法来组织类可以简化一个面向对象框架的公开架构，而又不减少功能的丰富性。</span></span><br><span class="line">        Class cls = <span class="built_in">NSClassFromString</span>(<span class="string">@&quot;__NSArrayM&quot;</span>);</span><br><span class="line">        Method method1 = class_getInstanceMethod(cls, <span class="keyword">@selector</span>(insertObject:atIndex:));</span><br><span class="line">        Method method2 = class_getInstanceMethod(cls, <span class="keyword">@selector</span>(mj_insertObject:atIndex:));</span><br><span class="line">        method_exchangeImplementations(method1, method2);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)mj_insertObject:(<span class="keyword">id</span>)anObject atIndex:(<span class="built_in">NSUInteger</span>)index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (anObject == <span class="literal">nil</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> mj_insertObject:anObject atIndex:index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>设置字典的key为nil的情况</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;NSMutableDictionary+Extension.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSMutableDictionary</span> (<span class="title">Extension</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        Class cls = <span class="built_in">NSClassFromString</span>(<span class="string">@&quot;__NSDictionaryM&quot;</span>);</span><br><span class="line">        Method method1 = class_getInstanceMethod(cls, <span class="keyword">@selector</span>(setObject:forKeyedSubscript:));</span><br><span class="line">        Method method2 = class_getInstanceMethod(cls, <span class="keyword">@selector</span>(mj_setObject:forKeyedSubscript:));</span><br><span class="line">        method_exchangeImplementations(method1, method2);</span><br><span class="line">        </span><br><span class="line">        Class cls2 = <span class="built_in">NSClassFromString</span>(<span class="string">@&quot;__NSDictionaryI&quot;</span>);</span><br><span class="line">        Method method3 = class_getInstanceMethod(cls2, <span class="keyword">@selector</span>(objectForKeyedSubscript:));</span><br><span class="line">        Method method4 = class_getInstanceMethod(cls2, <span class="keyword">@selector</span>(mj_objectForKeyedSubscript:));</span><br><span class="line">        method_exchangeImplementations(method3, method4);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)mj_setObject:(<span class="keyword">id</span>)obj forKeyedSubscript:(<span class="keyword">id</span>&lt;<span class="built_in">NSCopying</span>&gt;)key</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> mj_setObject:obj forKeyedSubscript:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)mj_objectForKeyedSubscript:(<span class="keyword">id</span>)key</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> mj_objectForKeyedSubscript:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2&gt;&lt;span id=&quot;oc-de-xiao-xi-ji-zhi&quot;&gt;OC 的消息机制&lt;/span&gt;&lt;a href=&quot;#oc-de-xiao-xi-ji-zhi&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;OC </summary>
      
    
    
    
    
    <category term="底层" scheme="http://example.com/tags/%E5%BA%95%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>底层四：block</title>
    <link href="http://example.com/2021/03/08/%E5%BA%95%E5%B1%82%E5%9B%9B%EF%BC%9Ablock/"/>
    <id>http://example.com/2021/03/08/%E5%BA%95%E5%B1%82%E5%9B%9B%EF%BC%9Ablock/</id>
    <published>2021-03-08T03:36:07.000Z</published>
    <updated>2021-03-17T02:32:23.508Z</updated>
    
    <content type="html"><![CDATA[<p>转换解决方案：支持<code>ARC</code>、指定<code>运行时系统版本</code>，（在对象增加weak属性时候要调用运行时，转换要用运行时）比如</p><pre><code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m</code></pre><p>普通转换</p><pre><code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main.cpp</code></pre><h2><span id="block-de-di-ceng-shi-xian">block 的底层实现</span><a href="#block-de-di-ceng-shi-xian" class="header-anchor">#</a></h2><p><strong>本质：block是封装了<code>函数调用</code>以及<code>函数调用环境</code>的OC<code>对象</code></strong> （有<code>isa</code>指针，是个对象，有函数调用环境&lt;函数地址、参数&gt;）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *isa;</span><br><span class="line">  <span class="keyword">int</span> Flags;</span><br><span class="line">  <span class="keyword">int</span> Reserved;</span><br><span class="line">  <span class="keyword">void</span> *FuncPtr;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  </span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> _age, <span class="keyword">int</span> flags=<span class="number">0</span>) : age(_age) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>后面复习，可以自己先动手转换一个CPP代码，再对照下面的注释学习</strong></p><p>Block 的定义以及实现代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">void</span> (^block)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">      NSLog(@<span class="string">&quot;this is a block %d&quot;</span>,age);</span><br><span class="line">&#125;;</span><br><span class="line">age = <span class="number">10</span>;</span><br><span class="line"> block();</span><br></pre></td></tr></table></figure><p>直接转换代码(去掉强制转换部分)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 通过构造函数创建</span></span><br><span class="line"><span class="comment">// 2.1 这里可以看出，age 之前只是作为值传递到block中，后面修改age的值，不会对block产生任何影响</span></span><br><span class="line"><span class="keyword">void</span>(*block)(<span class="keyword">void</span>) = </span><br><span class="line">   &amp;__main_block_impl_0(</span><br><span class="line">        __main_block_func_0,           </span><br><span class="line">        &amp;__main_block_desc_0_DATA, </span><br><span class="line">        age</span><br><span class="line">   );</span><br><span class="line"><span class="comment">// 2.2 age在这里修改，不会对block内部的age产生作用</span></span><br><span class="line">age = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 这里直接使用__main_block_impl_0 类型的 block 去访问 __block_impl对象中的FuncPtr ，可以从内存的层面去考虑</span></span><br><span class="line"> block-&gt;FuncPtr(block);</span><br></pre></td></tr></table></figure><p><strong>转换后的C++代码,分成三个部分</strong></p><p><code>struct __block_impl</code></p><p><code>struct __main_block_desc_0</code></p><p><code>struct __main_block_impl_0</code> : Block的具体实现，包含<code>struct __block_impl</code> 和 <code>struct __main_block_desc_0</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">    <span class="comment">// 注意这里不是指针，可以直接把结构体变量拿过来.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>struct __block_impl</code>： 这里是Block的具体实现细节</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *isa;</span><br><span class="line">    <span class="keyword">int</span> Flags;</span><br><span class="line">    <span class="keyword">int</span> Reserved;</span><br><span class="line">    <span class="comment">// block 的函数实现</span></span><br><span class="line">    <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>struct __main_block_desc_0</code>: Block 的描述</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> reserved;</span><br><span class="line">    <span class="comment">// block的尺寸</span></span><br><span class="line">    <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>重写结构体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里可以看出block的本质，是 __main_block_impl_0 结构体指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> *<span class="title">impBlock</span> =</span> (__bridge struct __main_block_impl_0 *)block;</span><br></pre></td></tr></table></figure><p>通过断点可以获取到block的一些内部信息，通过断点在Block实现部分，反编译到汇编，看最上面的一行调用栈，可以得出结论，<code>__block_impl</code> 内的<code>void *FuncPtr</code> 是函数的实现<br><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/59d594a99dda4ab2bd6ce73d40a545af~tplv-k3u1fbpfcp-zoom-1.image" alt="屏幕快照 2018-11-21 20.18.08.png"></p><p><strong>block底层实现图解（如果block捕获参数，会把对应的参数放到指定的位置上）</strong><br><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bccfb94af6d148d68f119061834f8bce~tplv-k3u1fbpfcp-zoom-1.image" alt="blcok底层实现.png"></p><p><strong><code>这里的参数指的是捕获的变量</code></strong></p><h2><span id="block-de-bian-liang-bu-huo-capture">block 的变量捕获( capture )</span><a href="#block-de-bian-liang-bu-huo-capture" class="header-anchor">#</a></h2><p><code>auto</code>: 自动变量，离开作用域自动销毁(无法定义全局变量)</p><p><code>static</code>：修饰局部变量的时候，产生<code>静态局部变量</code></p><p><code>静态局部变量</code>有以下特点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 该变量在全局数据区分配内存；</span><br><span class="line"></span><br><span class="line">2. 静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；</span><br><span class="line"></span><br><span class="line">3. 静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0；</span><br><span class="line"></span><br><span class="line">4. 它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束；</span><br></pre></td></tr></table></figure><p>应用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fn();</span><br><span class="line">    fn();</span><br><span class="line">    fn();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fn</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, n);</span><br><span class="line">    n++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>变量类型</th><th>捕获到block内部</th><th>访问方式</th></tr></thead><tbody><tr><td>局部变量 <code>auto类型</code></td><td><code>True</code></td><td>值传递</td></tr><tr><td>局部变量 <code>static类型</code></td><td><code>True</code></td><td>指针传递</td></tr><tr><td>全局变量</td><td><code>false</code></td><td>直接访问</td></tr></tbody></table><p><strong>局部变量是跨函数访问，肯定要进行捕获,全局变量是谁都可以访问，不需要捕获</strong></p><blockquote><p>原因：</p></blockquote><p><strong><code>局部变量传递原因：</code></strong> <code>auto</code>变量出了作用域就进行了释放，这个时候<code>block</code>内要访问这个变量，就必须进行值的捕获，否则会造成坏内存访问。而<code>static</code>始终驻留在<code>全局数据区</code>，直到程序运行结束。</p><p><strong><code>全局变量不会捕获原因：</code></strong> 静态局部变量虽然不会销毁，但是静态局部变量作用域会进行销毁，导致外部无法访问，所以捕获指向静态局部变量的指针。而全局变量作用域也不会进行销毁，可以直接访问，不需要捕获。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">auto <span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> height = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">void</span>(^block)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;age = %d, height = %d&quot;</span>,age, height);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">age = <span class="number">10</span>;</span><br><span class="line">height = <span class="number">10</span>;</span><br><span class="line">block();</span><br></pre></td></tr></table></figure><p>转化后</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  <span class="keyword">int</span> *height;</span><br><span class="line">  <span class="comment">// 看出赋值过程 age(_age), height(_height)，因为是指针传递，所以Block内部捕获到的值会跟随改变</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> _age, <span class="keyword">int</span> *_height, <span class="keyword">int</span> flags=<span class="number">0</span>) : age(_age), height(_height)</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>全局变量</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> age_ = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> height_ = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> (^block)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;age is %d, height is %d&quot;</span>, age_, height_);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        age_ = <span class="number">20</span>;</span><br><span class="line">        height_ = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        block();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> age_ = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> height_ = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> (*block)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并没有捕获全局变量，不需要捕获</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __test_block_desc_0 *desc, <span class="keyword">int</span> _a, <span class="keyword">int</span> *_b, <span class="keyword">int</span> flags=<span class="number">0</span>) : a(_a), b(_b) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><span id="block-de-lei-xing">block 的类型</span><a href="#block-de-lei-xing" class="header-anchor">#</a></h2><p><strong><code>block</code>有3种类型，可以通过调用<code>class</code>方法或者<code>isa</code>指针查看具体类型，最终都是继承自<code>NSBlock</code>类型</strong></p><blockquote><ul><li><strong>NSGlobalBlock</strong> （ _NSConcreteGlobalBlock ）</li><li><strong>NSStackBlock</strong> （ _NSConcreteStackBlock ）</li><li><strong>NSMallocBlock</strong> （ _NSConcreteMallocBlock ）</li></ul></blockquote><p>在<code>ARC</code>环境下验证</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">void</span>(^block)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">    NSLog(@<span class="string">&quot;one = %d&quot;</span>,age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>(^block1)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">    NSLog(@<span class="string">&quot;two&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">        </span><br><span class="line">NSLog(@<span class="string">&quot;\n %@ \n %@ \n %@ \n&quot;</span>, [block class],[block1 class], [^&#123;</span><br><span class="line">    NSLog(@<span class="string">&quot;one = %d&quot;</span>,age);</span><br><span class="line">&#125; class]);</span><br></pre></td></tr></table></figure><p>打印结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__NSMallocBlock__ </span><br><span class="line">__NSGlobalBlock__ </span><br><span class="line">__NSStackBlock__</span><br></pre></td></tr></table></figure><p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56cff7addb0d4aeca99ecdbc3864616b~tplv-k3u1fbpfcp-zoom-1.image" alt="block的类型.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> height = <span class="number">20</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">        NSLog(@<span class="string">&quot;数据段 - %p&quot;</span>, &amp;height);</span><br><span class="line">        NSLog(@<span class="string">&quot;栈段 - %p&quot;</span>, &amp;age);</span><br><span class="line">        NSLog(@<span class="string">&quot;堆段 - %p&quot;</span>, [[NSObject alloc] init]);</span><br><span class="line">        <span class="comment">// 猜测某个类型在哪个字段？</span></span><br><span class="line">        NSLog(@<span class="string">&quot;%p&quot;</span>, [JXPerson class]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如下 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 数据段 - <span class="number">0x1000011d0</span></span><br><span class="line"> 栈段 - <span class="number">0x7ffeefbff54c</span></span><br><span class="line"> 堆段 - <span class="number">0x101807ae0</span></span><br><span class="line"> <span class="comment">// 可以推测出类对象保存在数据区域</span></span><br><span class="line">---- <span class="number">0x1000011a8</span></span><br></pre></td></tr></table></figure><ul><li><p><code>程序区域(代码段)</code>一般放代码，包括<code>main函数</code>这些</p></li><li><p><code>数据区域</code>一般放<code>全局变量</code></p></li><li><p><code>堆</code>段放<code>alloc</code>出来的对象： 动态分配内存，要程序猿自己管理内存（申请、释放）</p></li><li><p><code>栈</code>空间一般放局部变量，自己分配、释放</p></li></ul><p><strong><code>block</code> 类型的判断标准（MRC）</strong></p><table><thead><tr><th>block类型</th><th>环境</th></tr></thead><tbody><tr><td><code>__NSGlobalBlock__</code></td><td>没有访问auto变量</td></tr><tr><td><code>__NSStackBlock__</code></td><td>访问了auto变量</td></tr><tr><td><code>__NSMallocBlock__</code></td><td><code>__NSStackBlock__</code>调用了copy</td></tr></tbody></table><p>在 MRC 环境下验证</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>(^block)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">    NSLog(@<span class="string">&quot;one&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">void</span>(^block2)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">    NSLog(@<span class="string">&quot;%d&quot;</span>,age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Block block3 = [block2 copy];</span><br><span class="line"></span><br><span class="line">NSLog(@<span class="string">&quot;\n%@ \n%@ \n%@&quot;</span>, [block class], [block2 class], [block3 class]);</span><br></pre></td></tr></table></figure><h3><span id="block-de-copy">block的copy</span><a href="#block-de-copy" class="header-anchor">#</a></h3><p><strong>每一种类型的<code>block</code>调用<code>copy</code>后的结果如下所示</strong></p><table><thead><tr><th>Block的类</th><th>副本源的配置存储域</th><th>复制效果</th></tr></thead><tbody><tr><td>_NSConcreteStackBlock</td><td>栈</td><td>从栈复制到堆</td></tr><tr><td>_NSConcreteGlobalBlock</td><td>程序的数据区域</td><td>什么也不做</td></tr><tr><td>_NSConcreteMallocBlock</td><td>堆</td><td>引用计数增加</td></tr></tbody></table><p><strong>在<code>ARC</code>环境下，编译器会根据情况自动将栈上的<code>block</code>复制到堆上，比如以下情况(自动调用一次<code>copy</code>)</strong></p><blockquote><ul><li><code>block</code>作为函数返回值时 (masory)</li><li>将<code>block</code>赋值给<code>__strong</code>指针时 (创建的对象默认就是<code>强指针</code>指向的，包括局部变量)</li><li><code>block</code>作为<code>Cocoa API</code>中方法名含有<code>usingBlock</code>的方法参数时(数组遍历)</li><li><code>block</code>作为<code>GCD API</code>的方法参数时</li></ul></blockquote><p><strong><code>MRC</code>下<code>block</code>属性的建议写法</strong></p><pre><code>@property (copy, nonatomic) void (^block)(void);</code></pre><p><strong><code>ARC</code>下<code>block</code>属性的建议写法(在<code>AR</code>C情况下会自动复制<code>strong</code>和<code>copy</code>两种类型引用效果相同)</strong>,</p><pre><code>@property (strong, nonatomic) void (^block)(void);@property (copy, nonatomic) void (^block)(void);</code></pre><h2><span id="dui-xiang-lei-xing-de-auto-bian-liang">对象类型的auto变量</span><a href="#dui-xiang-lei-xing-de-auto-bian-liang" class="header-anchor">#</a></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 将person对象捕获</span></span><br><span class="line">JXPerson *person = [[JXPerson alloc] init];</span><br><span class="line">person.age = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">JXBlock block= ^&#123;</span><br><span class="line">    NSLog(@<span class="string">&quot;------%d&quot;</span>, person.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>转换为CPP代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  <span class="comment">// 捕获的person变量是通过auto修饰的，如果通过static修饰，会变成 JXPerson ** person</span></span><br><span class="line">  JXPerson *person;</span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, JXPerson *_person, <span class="keyword">int</span> flags=<span class="number">0</span>) : person(_person) &#123;</span><br><span class="line">    ... ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里将带有<code>weak</code>的变量，转换成<code>CPP</code>代码</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__weak <span class="type">JXPerson</span> <span class="operator">*</span>weakPerson <span class="operator">=</span> person;</span><br><span class="line">block<span class="operator">=</span> <span class="operator">^</span>&#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;------%d&quot;</span>, weakPerson.age);</span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure><p>转换代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  <span class="comment">// 注意这里会有一个__weak 修饰，同外面 对象类型的auto变量的修饰符 相同</span></span><br><span class="line">  JXPerson *__weak weakPerson;</span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, JXPerson *__weak _weakPerson, <span class="keyword">int</span> flags=<span class="number">0</span>) : weakPerson(_weakPerson) &#123;</span><br><span class="line">    ... ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>将带有对象类型的<code>auto</code>变量的<code>block</code>，转换成<code>CPP</code>代码，可以看出结构体<code>__main_block_desc_0</code> 会有所改变</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">  <span class="comment">// 多出两个函数指针</span></span><br><span class="line">  <span class="keyword">void</span> (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>观察到 <code>__main_block_desc_0</code> 结构体多出两个函数指针，对应两个函数如下</strong></p><p>如果<code>Block</code>被拷贝到堆上，会调用内部的<code>__main_block_copy_0</code> 函数(以下简称<code>copy</code>函数)，<code>copy</code>函数会调用 <code>_Block_object_assign</code> 函数, 会根据<code>auto</code>变量的修饰符<code>（__strong、__weak、__unsafe_unretained）</code>做出相应的操作，引用计数加一（<code>__strong</code>），引用计数不改变（<code>__weak、__unsafe_unretained</code>）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;</span><br><span class="line"><span class="comment">//调用 _Block_object_assign 函数</span></span><br><span class="line">_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;weakPerson, (<span class="keyword">void</span>*)src-&gt;weakPerson, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果<code>block</code>从堆上移除,会调用<code>block</code>内部的<code>dispose</code>函数，<code>dispose</code>函数内部会调用<code>_Block_object_dispose</code>函数，<code>_Block_object_dispose</code>函数会自动释放引用的<code>auto</code>变量（类似于release，引用计数减一）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(struct __main_block_impl_0*src) &#123;</span><br><span class="line"></span><br><span class="line">_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;weakPerson, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>当<code>block</code>内部访问了<code>对象类型</code>的<code>auto</code>变量时</strong></p><ul><li>无论<code>MRC</code>或者<code>ARC</code>，如果<code>block</code>是在栈上，将不会对<code>auto变量</code>产生强引用 &lt; **<code>栈空间的Block没法保住对象类型的auto变量的命</code>** &gt; (在<code>MRC</code>环境通过<code>栈block</code>来进行验证，或者在<code>ARC</code>环境通过没有强引用指针指向的<code>Block</code>来验证)</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//MRC 环境</span></span><br><span class="line"><span class="type">JXBlock</span> block;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">JXPerson</span> <span class="operator">*</span>person <span class="operator">=</span> [[<span class="type">JXPerson</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">    person.age <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    block<span class="operator">=</span> <span class="operator">^</span>&#123;</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;------%d&quot;</span>, person.age);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 如果调用了copy，将block转换为__NSMallocBlock__,将保住person的命</span></span><br><span class="line">    <span class="comment">// block= [^&#123;</span></span><br><span class="line">    <span class="comment">//    NSLog(@&quot;------%d&quot;, person.age);</span></span><br><span class="line">    <span class="comment">// &#125; copy];</span></span><br><span class="line">    </span><br><span class="line">    [person release];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">NSLog</span>(@<span class="string">&quot;-------&quot;</span>);</span><br></pre></td></tr></table></figure><p>在 <code>NSLog(@&quot;-------&quot;);</code> 处打断点，重写<code>JXPerson</code>的<code>dealloc</code>方法，打印结果如下： </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重写dealloc的打印信息</span></span><br><span class="line">deallOC <span class="operator">-</span> <span class="type">JXPerson</span> 释放</span><br></pre></td></tr></table></figure><table><thead><tr><th>函数</th><th>调用时机</th></tr></thead><tbody><tr><td>copy函数</td><td>栈上的Block复制到堆时</td></tr><tr><td>dispose函数</td><td>堆上的Block被废弃时</td></tr></tbody></table><p><strong><code>总结：</code></strong></p><blockquote><p>如果<code>Block</code>是在<code>栈</code>空间，不会对内部的<code>对象类型的auto变量</code>产生强引用. 一旦<code>Block</code>在<code>堆空间</code>，会根据变量自身的修饰符(强引用或者弱引用)来进行相应的引用操作。</p></blockquote><h2><span id="block">__block</span><a href="#block" class="header-anchor">#</a></h2><p><strong>block 无法修改局部变量，转换成CPP代码可以看到本质，就是两者并不在同一个函数内，如果想要修改可以使用<code>静态局部变量</code>(通过指针引用，可修改) 或者使用<code>__block</code></strong></p><pre><code>1.__block可以用于解决block内部无法修改auto变量值的问题2.__block不能修饰全局变量、静态变量（static）</code></pre><p><strong>编译器会将__block变量包装成一个<code>对象</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line"> <span class="keyword">void</span>(^myBlock)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        NSLog(@<span class="string">&quot;%d&quot;</span>,age);</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p>转换： 这里是<code>block</code>所转换的结构体，可以看出对应的<code>age</code>是一个指向<code>__Block_byref_age_0</code> 结构体的指针.从构造函数的赋值 <code>age(_age-&gt;__forwarding)</code> 可以看出最后是通过结构体的<code>fowarding</code>指针进行的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">    __Block_byref_age_0 *age; <span class="comment">// by ref</span></span><br><span class="line">     __main_block_impl_0(</span><br><span class="line">            <span class="keyword">void</span> *fp, </span><br><span class="line">            struct __main_block_desc_0 *desc, </span><br><span class="line">            __Block_byref_age_0 *_age, </span><br><span class="line">            <span class="keyword">int</span> flags=<span class="number">0</span>) : age(_age-&gt;__forwarding) &#123;</span><br><span class="line">             ... ...</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们找到 <code>__Block_byref_age_0</code> 的定义后发现，真实<code>age</code>的值，被放到结构体中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// __ block 会单独生成一个结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">Block_byref_age_0</span> &#123;</span></span><br><span class="line">   <span class="comment">// 因为包含isa，所以__block 相当于一个对象</span></span><br><span class="line">    <span class="keyword">void</span> *__isa; </span><br><span class="line">   __Block_byref_age_0 *__forwarding;</span><br><span class="line">   <span class="keyword">int</span> __flags;</span><br><span class="line">   <span class="keyword">int</span> __size;</span><br><span class="line">   <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后找到函数中 <code>__block int age = 10;</code> 转换的代码.我们发现了如下的一个结构体赋值过程，<code>10</code>被赋值给结构体内的<code>age</code>，而<code>__forwarding</code>指向自身</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">__Block_byref_age_0 age = &#123;</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            &amp;age, <span class="comment">// __Block_byref_age_0 age 指向自己的指针</span></span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            <span class="keyword">sizeof</span>(__Block_byref_age_0),</span><br><span class="line">            <span class="number">10</span></span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><p>参考题</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (^block)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> test() &#123;</span><br><span class="line">    </span><br><span class="line">    __block <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    block = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>,age);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    age = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        test();</span><br><span class="line">        </span><br><span class="line">        block();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果是20</span></span><br></pre></td></tr></table></figure><p>打印结果是<code>20</code>，因为<code>_ _block</code>是生成了一个对象，拷贝到block内部，对象修改属性会生效</p><h3><span id="nei-cun-guan-li">内存管理</span><a href="#nei-cun-guan-li" class="header-anchor">#</a></h3><h4><span id="block-xiu-gai-pu-tong-bian-liang"><code>__block</code> 修改普通变量</span><a href="#block-xiu-gai-pu-tong-bian-liang" class="header-anchor">#</a></h4><p>我们可以看到刚刚在<code>block</code>中引用带有<code>__block</code>的代码，转换后的代码描述部分如下，生成了管理对象的函数<code>copy</code>和<code>dispose</code>，原因是因为<code>__block</code>相当于一个对象，在<code>block</code>内部,需要<code>block</code>进行内存管理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">  <span class="keyword">void</span> (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>当<code>block</code>在栈上时，并不会对<code>__block变量</code>产生强引用(可以通过MRC，使用<code>栈空间block</code>验证)</strong>   </p><p><strong>当block被copy到堆时</strong></p><blockquote><ul><li>会调用<code>block</code>内部的<code>copy</code>函数</li><li><code>copy</code>函数内部会调用<code>_Block_object_assign</code>函数</li><li><code>_Block_object_assign</code>函数会对<code>__block</code>变量形成强引用（<code>retain</code>）</li></ul></blockquote><p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33b90b44774b45a9ae97ab1904dbef30~tplv-k3u1fbpfcp-zoom-1.image" alt="__block copy.png"></p><p><strong>当block从堆中移除时</strong></p><blockquote><ul><li>会调用block内部的dispose函数</li><li>dispose函数内部会调用_Block_object_dispose函数</li><li>_Block_object_dispose函数会自动释放引用的__block变量（release）</li></ul></blockquote><p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd38444272434307a93a6dfea8b0888e~tplv-k3u1fbpfcp-zoom-1.image" alt="__block dispose.png"></p><p><strong><code>总结：对象类型的auto变量和__block修饰的变量</code>的相同点和区别</strong></p><p><strong>相同点</strong></p><blockquote><ul><li>当<code>Block</code>在栈上时，不会对<code>auto对象类型</code>、<code>__block修饰的变量</code>产生强引用</li><li>当<code>Block</code>拷贝到堆上时，会对 <code>auto对象类型</code>、<code>__block修饰的变量</code> 调用<code>copy</code>函数。产生强引用（引用计数加一（<code>__strong</code>），引用计数不改变（<code>__weak、__unsafe_unretained</code>））</li><li>如果<code>Block</code>从堆中移除，会对 <code>auto对象类型</code>、<code>__block修饰的变量</code> 调用<code>dispose</code>函数。（引用计数减一）</li></ul></blockquote><p><strong>区别</strong></p><blockquote><ul><li>使用<code>__block</code>修饰的基本数据类型在<code>block</code>中肯定是强引用，基本数据类型没法使用 <code>__weak</code> 修饰， 但是使用<code>__block</code>修饰的对象如果使用了<code>weak</code>、<code>unsafe_retain</code>的话，会是弱引用，对象使用了<code>strong</code>的话，就是强引用</li></ul></blockquote><h3><span id="forwarding-zhi-zhen">__forwarding 指针</span><a href="#forwarding-zhi-zhen" class="header-anchor">#</a></h3><p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7e2a26cc59f459d9e321398d5c2a394~tplv-k3u1fbpfcp-zoom-1.image" alt="__block forwarding指针.png"></p><h4><span id="block-xiu-shi-de-dui-xiang-lei-xing"><code>__block</code> 修饰的对象类型</span><a href="#block-xiu-shi-de-dui-xiang-lei-xing" class="header-anchor">#</a></h4><p>跟修饰基本数据类型一样，也是生成一个新的对象，新的对象里面有<code>__block</code>修饰的参数</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="type">JXPerson</span> <span class="operator">*</span>person <span class="operator">=</span> [[<span class="type">JXPerson</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">void(<span class="operator">^</span>myBlock)(void) <span class="operator">=</span> <span class="operator">^</span>&#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;%@&quot;</span>,person);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>转换后的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  __Block_byref_person_0 *person; <span class="comment">// by ref</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, __Block_byref_person_0 *_person, <span class="keyword">int</span> flags=<span class="number">0</span>) : person(_person-&gt;__forwarding) &#123;</span><br><span class="line">    ... ... </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>__Block_byref_person_0 </code>是一个单独的结构体， 当<code>__Block_byref_person_0</code> 被拷贝到堆上时，会调用 <code>__Block_byref_id_object_copy</code> 函数，将对应的<code>person</code>调用<code>_Block_object_assign</code> 方法，相反释放的时候，调用<code>dipose</code>函数 (在MRC情况下，不会对<code>person</code>形成强引用，肯定是弱引用)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">Block_byref_person_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *__isa; <span class="comment">// 8</span></span><br><span class="line">__Block_byref_person_0 *__forwarding; <span class="comment">// 8</span></span><br><span class="line"> <span class="keyword">int</span> __flags;  <span class="comment">// 4</span></span><br><span class="line"> <span class="keyword">int</span> __size;   <span class="comment">// 4</span></span><br><span class="line"> <span class="comment">// 比基本数据类型，对了两个函数指针</span></span><br><span class="line"> <span class="keyword">void</span> (*__Block_byref_id_object_copy)(<span class="keyword">void</span>*, <span class="keyword">void</span>*); <span class="comment">// 8</span></span><br><span class="line"> <span class="keyword">void</span> (*__Block_byref_id_object_dispose)(<span class="keyword">void</span>*);  <span class="comment">// 8</span></span><br><span class="line"> <span class="comment">// 这里是对应的对象变量(比基本数据类型多了类型修饰符)</span></span><br><span class="line"> JXPerson *__strong person;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过查看main函数的CPP源码，可以拿到<code>__Block_byref_person_0</code> 对应的两个函数指针对应的函数实现<code>__Block_byref_id_object_copy_131</code>和<code>__Block_byref_id_object_dispose_131</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __Block_byref_id_object_copy_131(<span class="keyword">void</span> *dst, <span class="keyword">void</span> *src) &#123;</span><br><span class="line"><span class="comment">// 这里的dst指的是结构体的首地址，+40 正好对应到  JXPerson *__strong person; 的位置</span></span><br><span class="line"><span class="comment">// 所以这里的目的是对person对象，调用 assign 函数</span></span><br><span class="line"> _Block_object_assign((<span class="keyword">char</span>*)dst + <span class="number">40</span>, *(<span class="keyword">void</span> * *) ((<span class="keyword">char</span>*)src + <span class="number">40</span>), <span class="number">131</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __Block_byref_id_object_dispose_131(<span class="keyword">void</span> *src) &#123;</span><br><span class="line"> _Block_object_dispose(*(<span class="keyword">void</span> * *) ((<span class="keyword">char</span>*)src + <span class="number">40</span>), <span class="number">131</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5abd730c264245d8963fee526cca3df2~tplv-k3u1fbpfcp-zoom-1.image" alt="__blcok JXPerson.png"></p><p><strong>在 <code>ARC</code> 情况下</strong></p><blockquote><p>对<code>__block</code>都是强引用</p><p>对<code>对象</code>是按照对象的修饰词<code>weak</code>和<code>strong</code>决定</p><p>对<code>__block对象</code> 这种类型是怎么修饰的，应该是按照<code>__block</code> 结构体对象强引用，结构体对象内部的类对象是按照对象的<code>weak</code>和<code>assign</code>来决定引用类型</p></blockquote><p><strong>在<code>MRC</code>情况下</strong></p><pre><code>__Block person = [Person new]JXBlock myBlock = ^&#123;    nslog(@&quot;%@&quot;,person);&#125;person 永远都是弱引用</code></pre><h2><span id="block-xun-huan-ying-yong">block 循环应用</span><a href="#block-xun-huan-ying-yong" class="header-anchor">#</a></h2><p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f563f950361040c4bff072d019f8b672~tplv-k3u1fbpfcp-zoom-1.image" alt="循环应用.png"></p><pre><code>__unsafe_unretained 对象销毁后不会置空__weak 对象销毁后置为nil</code></pre><h3><span id="arc">ARC</span><a href="#arc" class="header-anchor">#</a></h3><pre><code>1.除了弱引用，还可以使用__block来解决循环引用，但是需要进行释放操作，需要调用block2.在block内部使用__ strong 修饰 weakSelf 的目的： 避免在使用中weakSelf释放掉，举例子： weakSelf -&gt; age 无法通过编译（解决编译器问题）</code></pre><p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a2048b1af7d4e8a856d8d245fe6b999~tplv-k3u1fbpfcp-zoom-1.image" alt="ARC解决循环引用.png"></p><h3><span id="mrc">MRC</span><a href="#mrc" class="header-anchor">#</a></h3><p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bcc2409dbaa24f388d75b12921b227a6~tplv-k3u1fbpfcp-zoom-1.image" alt="MRC解决循环引用.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;转换解决方案：支持&lt;code&gt;ARC&lt;/code&gt;、指定&lt;code&gt;运行时系统版本&lt;/code&gt;，（在对象增加weak属性时候要调用运行时，转换要用运行时）比如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;xcrun -sdk iphoneos clang -arch arm64 -re</summary>
      
    
    
    
    
    <category term="底层" scheme="http://example.com/tags/%E5%BA%95%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>网络应用层</title>
    <link href="http://example.com/2021/03/08/%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    <id>http://example.com/2021/03/08/%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82/</id>
    <published>2021-03-08T03:36:07.000Z</published>
    <updated>2021-03-10T09:35:23.228Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="ying-yong-ceng">应用层</span><a href="#ying-yong-ceng" class="header-anchor">#</a></h1><h2><span id="ji-chu-gai-nian">基础概念</span><a href="#ji-chu-gai-nian" class="header-anchor">#</a></h2><h4><span id="ying-yong-ceng-chang-jian-de-xie-yi">应用层常见的协议</span><a href="#ying-yong-ceng-chang-jian-de-xie-yi" class="header-anchor">#</a></h4><ul><li>超文本传输：<code>HTTP</code>、<code>HTTPS</code></li><li>文件传输：<code>FTP</code></li><li>电子邮件：<code>SMTP</code>、<code>POP3</code>、<code>IMAP</code></li><li>动态主机配置：<code>DHCP</code></li><li>域名系统：<code>DNS</code><h4><span id="yu-ming-domain-name">域名（Domain Name）</span><a href="#yu-ming-domain-name" class="header-anchor">#</a></h4>由于IP地址不方便记忆，并且不能表达组织的名称和性质，人们设计出了域名（比如<code>baidu.com</code>）,但实际上，为了能够访问到具体的主机，最终还是得知道目标主机的IP地址。<a href="https://wanwang.aliyun.com/">域名申请注册</a></li></ul><blockquote><p>如果干脆全程使用域名，不用IP地址会有什么问题？<br>IP地址是固定4个字节，域名随随便便都至少十几个字节，这无疑会增加路由器的负担，浪费流量</p></blockquote><p>根据级别不同，域名可以分为：</p><ul><li>顶级域名(<code>Top-level Domain</code>, 简称<code>TLD</code>)</li><li>二级域名</li><li>三级域名</li><li>…</li></ul><h5><span id="ding-ji-yu-ming">顶级域名</span><a href="#ding-ji-yu-ming" class="header-anchor">#</a></h5><p>通用顶级域名(<code>General Top-level Domain</code>,简称<code>gTLD</code>) 包括 <code>.com(公司)</code> <code>.net(网络机构)</code> <code>.org(组织机构)</code> <code>.edu(教育)</code> <code>.gov(政府部门)</code> <code>.int(国际组织)</code> 等</p><p>国家及地区顶级域名(<code>Country Code Top-level Domain</code> 简称 <code>ccTLD</code>) 包括 <code>.cn(中国)</code> <code>.jp(日本)</code> <code>.uk(英国)</code></p><p>新通用顶级域名(<code>New Generic Top-level Domain</code>, 简称<code>New gTLD</code>) 包括 <code>.vip</code> <code>.xyz</code> <code>.top</code> <code>.club</code> <code>.shop</code> 等</p><h5><span id="er-ji-yu-ming">二级域名</span><a href="#er-ji-yu-ming" class="header-anchor">#</a></h5><p>二级域名是指顶级域名之下的域名</p><ul><li>在通用顶级域名下，它一般指域名注册人的名称，例如<code>google</code>、<code>baidu</code>、<code>microsoft</code></li><li>在国家及地区的顶级域名下，它一般指注册类别的，例如<code>com</code>、<code>edu</code>、<code>gov</code>、<code>net</code>等</li></ul><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf1ae1ae72834f6b8efb645c88ab350b~tplv-k3u1fbpfcp-watermark.image"></p><h2><span id="dns">DNS</span><a href="#dns" class="header-anchor">#</a></h2><ul><li><code>DNS</code> 的全称是：<code>Domain Name System</code>，译为：域名系统</li><li>利用<code>DNS</code>协议，可以将域名(比如<code>baidu.com</code>) 解析成对应的IP地址(比如 <code>220.181.38.148</code>)</li><li><code>DNS</code> 可以基于<code>UDP</code>协议，也可以基于<code>TCP</code>协议，服务器占用<code>53</code>端口</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1cbb128f242e4317b2f9543c5e84bf61~tplv-k3u1fbpfcp-watermark.image"></p><h4><span id="dns-fu-wu-qi">DNS 服务器</span><a href="#dns-fu-wu-qi" class="header-anchor">#</a></h4><ul><li>客户端会首先访问最近的一台<code>DNS</code>服务器(也就是客户端自己配置的DNS服务器)</li><li>所有的<code>DNS</code>服务器都记录了DNS根域名服务器（<code>域名最后隐藏的&quot;.&quot;</code>） 的<code>IP</code>地址</li><li>上级<code>DNS</code>服务器记录了下一级<code>DNS</code>服务器的<code>IP</code>地址</li><li>全球一共<code>13</code>台<code>IPv4</code>的<code>DNS</code>根域名服务器、<code>25</code>台<code>IPv6</code>的<code>DNS</code>根域名服务器</li></ul><h5><span id="chang-yong-ming-ling">常用命令</span><a href="#chang-yong-ming-ling" class="header-anchor">#</a></h5><p><code>ipconfig /displaydns</code> : 查看DNS缓存记录</p><p><code>ipconfig /flushdns</code> :清空DNS缓存记录</p><p><code>ping</code> 域名</p><p><code>nslookup</code> 域名</p><h2><span id="dhcp">DHCP</span><a href="#dhcp" class="header-anchor">#</a></h2><ul><li><code>DHCP</code>(Dynamic Host Configuration Protocol),译为：动态主机配置协议<ul><li><code>DHCP</code>协议基于<code>UDP</code>协议，客户端是<code>68</code>端口，服务器是<code>67</code>端口</li></ul></li><li><code>DHCP</code>服务器会从<code>IP</code>地址池中，挑选一个<code>IP</code>地址“出租”给客户端一段时间，时间到期就回收它们<ul><li>平时家里上网的路由器就可以充当<code>DHCP</code>服务器</li></ul></li></ul><h4><span id="fen-pei-ip-di-zhi-de-4-ge-jie-duan">分配IP地址的4个阶段</span><a href="#fen-pei-ip-di-zhi-de-4-ge-jie-duan" class="header-anchor">#</a></h4><p><code>DISCOVER</code>: 发现服务器，发广播包(源<code>IP</code>是<code>0.0.0.0</code>,目标<code>IP</code>是<code>255.255.255.255</code>,目标<code>MAC</code>是<code>FF:FF:FF:FF:FF:FF</code>)</p><p><code>OFFER</code>:提供租约，服务器返回可以租用的<code>IP</code>地址，以及租用期限、子网掩码、网关、DNS等信息，注意：这里可能会有多个服务器提供租约</p><p><code>REQUEST</code>:选择<code>IP</code>地址，客户端选择一个<code>OFFER</code>，发送广播包进行回应</p><p><code>ACKNOWLEDGE</code>：确认，被选中的服务器发送<code>ACK</code>数据包给客户端，至此<code>IP</code>地址分配完毕</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52539d5cc0874e249ed5194f7c168662~tplv-k3u1fbpfcp-watermark.image"></p><h5><span id="xi-jie">细节</span><a href="#xi-jie" class="header-anchor">#</a></h5><p>DHCP服务器可以跨网段分配IP地址么？(DHCP服务器、客户端不在同一个网段)</p><blockquote><p>可以借助<code>DHCP</code>中继代理<code>(DHCP Relay Agent)</code>实现跨网段分配<code>IP</code>地址</p></blockquote><p>自动续约</p><blockquote><p>客户端会在租期不足的时候，自动向<code>DHCP</code>服务器发送<code>REQUEST</code>信息申请续约</p></blockquote><p>常用命令</p><p><code>ipconfig /all</code> :可以看到DHCP相关的详细信息，比如租约过期时间、DHCP服务器地址等</p><p><code>ipconfig /release</code>:释放租约</p><p><code>ipconfig /renew</code>:重新申请<code>IP</code>地址、申请续约(延长租期)</p><h2><span id="http">HTTP</span><a href="#http" class="header-anchor">#</a></h2><p><code>HTTP(Hyper Text Transfer Protocol)</code>,译为超文本传输协议，是互联网中应用最广泛的应用层协议之一。设计<code>HTTP</code>最初的目的是：提供一种发布和接收<code>HTML</code>页面的方法，由<code>URI</code>来标识具体的资源,后面用<code>HTTP</code>来传递的数据格式不仅仅是<code>HTML</code>，应用非常广泛</p><p><code>HTML（Hyper Text Markup Language）</code>：超文本(不单单可以表达文本，还可以表达超过文本的信息)标记语言,用以编写网页</p><blockquote><p><code>URI</code>包含<code>URL</code>，可能是不完整的一个路径（相对路径）,<code>URL</code>是完整路径</p></blockquote><h4><span id="ban-ben">版本</span><a href="#ban-ben" class="header-anchor">#</a></h4><ul><li><p>1991年，HTTP/0.9</p><blockquote><p>只支持<code>GET</code>请求方法获取文本数据(比如<code>HTML</code>文档)，且不支持请求头、响应头等，无法向服务器传递太多的数据</p></blockquote></li><li><p>1996年，HTTP/1.0</p><blockquote><p>支持<code>POST</code>、<code>HEAD</code>等请求方法，支持请求头、响应头等，支持更多种数据类型(不再局限于文本数据)，浏览器的每次请求都需要跟服务器建立一个<code>TCP</code>连接，请求处理完成后立即断开<code>TCP</code>连接</p></blockquote></li><li><p>1997年，HTTP/1.1 (最经典、使用最广泛的版本)</p><blockquote><p>支持<code>PUT</code>、<code>DELETE</code>等请求方法，采用持久连接(<code>Connection:Keep-alive</code>),多个请求可以共用同一个<code>TCP</code>连接 (以前的请求是请求网页<code>HTML</code>要三次握手、四次挥手，如果网页里面有图片又要三次握手、四次挥手，现在是可以一次连接，传递完毕资源后再断开连接，或者根本不断开连接，直到关闭网页再关闭连接)</p></blockquote></li><li><p>2015年，HTTP/2.0</p></li><li><p>2018年，HTTP/3.0</p></li></ul><h4><span id="biao-zhun">标准</span><a href="#biao-zhun" class="header-anchor">#</a></h4><ul><li><p><code>HTTP</code>的标准由万维网协会(<code>W3C</code>)、互联网工程任务组(<code>IETE</code>)协调制定，最终发布了一些了的<code>RFC</code></p></li><li><p><a href="https://www.rfc-editor.org/standards">RFC</a> (Request For Comments，可以译为：请求意见稿)，<code>HTTP/1.1</code> 最早是在1997年的<a href="https://tools.ietf.org/html/rfc2068">RFC_2068</a>中记录的，该规范在1999年的<a href="https://tools.ietf.org/html/rfc2626">RFC_2626</a>中已作废，2014年又由<a href="https://tools.ietf.org/html/rfc7230">RFC_7230</a>系列的<code>RFC</code>取代。</p></li><li><p><code>HTTP/2</code>标准于2015年5月以<a href="https://tools.ietf.org/html/rfc7540">RFC_7540</a>正式发表，取代<code>HTTP/1.1</code>成为<code>HTTP</code>的实现标准</p></li><li><p>中国的RFC</p></li><li><p>1996年3月，清华大学提交的适应不同国家和地区中文编码的汉字统一传输标准被IETF通过为<a href="https://tools.ietf.org/html/rfc1922">RFC_1922</a>，成为中国大陆第一个被认可为RFC文件的提交协议</p></li></ul><h4><span id="bao-wen-ge-shi">报文格式</span><a href="#bao-wen-ge-shi" class="header-anchor">#</a></h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40270a146bb64b81aca5013784698768~tplv-k3u1fbpfcp-watermark.image" alt="报文格式"><br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/614c79c4f39e48139d949d9133264cc2~tplv-k3u1fbpfcp-watermark.image" alt="报文格式1"></p><p> <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69238669ad384952b5521d1367ee33b4~tplv-k3u1fbpfcp-watermark.image"><br> <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d0bf6b2bf6f4f3eba64de82690363d5~tplv-k3u1fbpfcp-watermark.image"></p><p>注意每个换行部分有一个<code>回车和换行符</code>,请求头和请求体之间也有<code>回车和换行符</code></p><h5><span id="abnf">ABNF</span><a href="#abnf" class="header-anchor">#</a></h5><p><code>ABNF</code>是<code>BNF</code>(Backs-Naur Form,译为：巴科斯-瑙尔范式)的修改、增强版</p><p>在<a href="https://tools.ietf.org/html/rfc5234">RFC_5234</a>中表明：<code>ABNF</code>用作<code>internet</code>中通信协议的定义语言</p><p><code>ABNF</code>是最严谨的<code>HTTP</code>报文格式描述形式，脱离<code>ABNF</code>谈论<code>HTTP</code>报文格式，往往都是片面、不严谨的</p><p>关于HTTP报文格式的定义</p><ul><li><p><a href="https://tools.ietf.org/html/rfc2616%23section-4">RFC 2616 4.HTTP Message</a> (旧)</p></li><li><p><a href="https://tools.ietf.org/html/rfc7230">RFC 7230 3.Message Format</a> (新)</p></li></ul><p><strong>ABNF核心规则</strong></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bda95486b02a4855a292f21c0d4d6e82~tplv-k3u1fbpfcp-watermark.image"></p><h6><span id="abnf-biao-shi-de-bao-wen-ge-shi">ABNF表示的报文格式</span><a href="#abnf-biao-shi-de-bao-wen-ge-shi" class="header-anchor">#</a></h6><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1dcf0fd226e940649c3d6d364c72c63f~tplv-k3u1fbpfcp-watermark.image"></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b5ca7f0b79b47769cc173c3e381520c~tplv-k3u1fbpfcp-watermark.image"></p><h4><span id="url-de-bian-ma">URL的编码</span><a href="#url-de-bian-ma" class="header-anchor">#</a></h4><p>URL中一旦出现了一些特殊字符(比如中文、空格)，需要进行<a href="https://tool.oschina.net/encode?type=4">编码</a></p><p>在浏览器地址栏输入URL时，是采用UTF-8进行编码</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc932c8a3e0b4240abce2d0b195d3413~tplv-k3u1fbpfcp-watermark.image"></p><h4><span id="qing-qiu-fang-fa">请求方法</span><a href="#qing-qiu-fang-fa" class="header-anchor">#</a></h4><p><a href="https://tools.ietf.org/html/rfc7231">RFC 7231,section 4: Request methods</a>：描述了8中请求方法<br><code>GET</code> <code>HEAD</code> <code>POST</code> <code>PUT</code> <code>DELETE</code> <code>CONNECT</code> <code>OPTIONS</code> <code>TRACE</code></p><p><a href="https://tools.ietf.org/html/rfc5789%23section-2">RFC 5789,section 2: Patch method</a>: 描述了<code>PATCH</code>方法</p><p><code>POST（增删改）</code>：常用于添加、修改、删除的操作，请求参数可以放到请求体中(没有大小限制)</p><p><code>GET（查）</code> : 常用于读取的操作，请求参数直接拼接在URL的后面(浏览器对<code>URL</code>是有长度限制的)</p><p><code>HEAD</code>:请求得到与<code>GET</code>请求相同的响应，但没有响应体</p><pre><code>使用场景举例：在下载一个大文件前，先获取其大小，再决定是否要下载。以此可以节约带宽资源。</code></pre><p><code>OPTIONS</code>:用于获取目的资源所支持的通信选项，比如服务器支持的请求方法<br> <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10d0b236dbca433d939f0f4c48cbc968~tplv-k3u1fbpfcp-watermark.image"></p><p> <code>PUT</code>:用于对已存在的资源进行整体覆盖</p><p> <code>PATCH</code>：用于对资源进行部分修改(资源不存在，会创建新的资源)</p><p> <code>DELETE</code>：用于删除指定的资源</p><p> <code>TRACE</code>:请求服务器回显其收到的请求信息（发出什么就收到什么），主要用于HTTP请求的测试或诊断</p><p> <code>CONNECT</code>：可以开启一个客户端与所请求资源之间的双向沟通的通道，它可以用来创建隧道(<code>tunnel</code>)</p><pre><code> 可以用来访问采用了SSL(HTTPS)协议的站点</code></pre><h4><span id="tou-bu-zi-duan">头部字段</span><a href="#tou-bu-zi-duan" class="header-anchor">#</a></h4><p>头部字段可以分为4种类型 （了解即可，主要看请求头和响应头）</p><p><code>请求头字段(Request Header Fields)</code>: 有关要获取的资源或客户端本身信息的消息头</p><p><code>响应头字段(Response Header Fields)</code>: 有关响应的补充信息，比如服务器本身（名称和版本等）的消息头</p><p><code>实体头字段(Entity Header Fields)</code>: 有关实体主体的更多信息，比如主体长度(<code>Content-Length</code>) 或其<code>MIME</code>类型</p><p><code>通用头字段(General Header Fields)</code>: 同时适用于请求和响应消息，但与消息主体无关的消息头</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a2ff8388cc34a6e99d2571cc80d44a5~tplv-k3u1fbpfcp-watermark.image" alt="请求头"></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5eb8a4f321c94ef188e249fbd502b965~tplv-k3u1fbpfcp-watermark.image" alt="响应头"></p><h5><span id="bu-fen-xiang-jie">部分详解</span><a href="#bu-fen-xiang-jie" class="header-anchor">#</a></h5><p>请求体<code>Origin</code> 和 响应头<code>Access-Control-Allow-Origin</code> 用在跨域，受到同源策略（基于安全策略）影响，前端和后台要进行跨域处理</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40b7bfbff20948e1860f7f82e3e07670~tplv-k3u1fbpfcp-watermark.image"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/061b7d6da8814ea2920cc781836f4776~tplv-k3u1fbpfcp-watermark.image"></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1e6c50f4f2d4fe181fd96bf3d5cd890~tplv-k3u1fbpfcp-watermark.image"></p><p><code>Cookie</code> 和 <code>Set-Cookie</code><br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b049f666c1a24d328e2f77b5ec57aef5~tplv-k3u1fbpfcp-watermark.image"><br><code>Cookie</code>: 在客户端（浏览器）存储一些数据，存储到本地磁盘（硬盘），服务器可以返回<code>Cookie</code>交给客户端去存储</p><p><code>Session</code>:在服务器存储一些数据，存储到内存中（默认时长是30分钟）</p><h4><span id="zhuang-tai-ma-status-code">状态码(Status Code)</span><a href="#zhuang-tai-ma-status-code" class="header-anchor">#</a></h4><p>在<a href="https://tools.ietf.org/html/rfc2616%23section-10">RFC 2616 10.Status Code Definitions</a>规范中定义,状态码指示HTTP请求是否已成功完成</p><p>状态码可以分为5类：</p><ul><li>信息响应：100~199</li><li>成功响应：200~299</li><li>重定向：300~399</li><li>客户端错误：400~499</li><li>服务器错误：500~599</li></ul><h5><span id="chang-jian-zhuang-tai-ma">常见状态码</span><a href="#chang-jian-zhuang-tai-ma" class="header-anchor">#</a></h5><ul><li>100 Continue<blockquote><p>请求的初始部分已经被服务器收到，并且没有被服务器拒绝。客户端应继续发送剩余的请求，如果请求已经完成，就忽略这个响应</p></blockquote></li><li>200 OK<blockquote><p>请求成功</p></blockquote></li><li>302 Found<blockquote><p>请求的资源被暂时的移动到了由<code>Location</code>头部指定的<code>URL</code>上 (会进行重定向)</p></blockquote></li><li>304 Not Modified<blockquote><p>说明无需再次传输请求的内容，也就是说可以使用缓存的内容(服务器给回的响应体中没有数据，使用缓存资源)</p></blockquote></li><li>400 Bad Request<blockquote><p>由于语法无效，服务器无法理解该请求</p></blockquote></li><li>401 Unauthorized<blockquote><p>用于缺乏目标资源要求的身份验证凭证(网页中出现身份验证的弹框)</p></blockquote></li><li>403 Forbidden<blockquote><p>服务器端有能力处理该请求，但是拒绝授权访问</p></blockquote></li><li>404 Not Found<blockquote><p>服务端无法找到所请求的资源</p></blockquote></li><li>405 Method Not Allowed <blockquote><p>服务器禁止使用当前<code>HTTP</code>方法的请求 （服务器可以处理<code>GET</code>方法，但是某个请求禁止了<code>GET</code>方法）</p></blockquote></li><li>406 Not Acceptable<blockquote><p>服务端无法提供与<code>Accept—Charset</code>以及<code>Accept-Laguage</code>指定的值相匹配的响应</p></blockquote></li><li>408 Request Timeout<blockquote><p>服务器响应将没有在使用的连接关闭，一些服务器在空闲连接上发送此消息，即便是客户端没有发送任何请求的情况下</p></blockquote></li><li>500 Internal Server Error<blockquote><p>所请求的服务器遇到意外的情况，并阻止其执行请求（服务器宕机）</p></blockquote></li><li>501 Not Implemented <blockquote><p>请求的方法不被服务器支持，因此无法被处理，服务器必须支持的方法（即不会返回这个状态码的方法）只有<code>GET</code>和<code>HEAD</code></p></blockquote></li><li>502 Bad Gateway<blockquote><p>作为网关或代理角色的服务器，从上游服务器(如<code>tomcat</code>)中接收的响应是无效的</p></blockquote></li><li>503 Service Unavailable<blockquote><p>服务器尚未处于可以接受请求的状态（通常造成这种情况的原因是由于服务器停机维护或者已超载）</p></blockquote></li></ul><h4><span id="biao-dan-form-ti-jiao">表单(form)提交</span><a href="#biao-dan-form-ti-jiao" class="header-anchor">#</a></h4><h5><span id="chang-yong-shu-xing">常用属性</span><a href="#chang-yong-shu-xing" class="header-anchor">#</a></h5><blockquote><p><code>action</code>：请求的<code>URI</code></p></blockquote><blockquote><p><code>method</code>：请求的方法 (<code>GET</code> 、 <code>POST</code>)</p></blockquote><blockquote><p><code>enctype</code>：<code>post</code>请求时，请求体的编码方式</p><ul><li><code>application/x-www-form-urlencoded</code>（默认值）<ul><li>用&amp;分隔参数，用=分隔键和值，字符用URL编码方式进行编码,举例： <code>username=123&amp;password=456</code>（类似普通的post请求体格式）</li></ul></li><li><code>multipart/form-data</code><ul><li>文件上传时候必须使用这种编码方式</li></ul></li></ul></blockquote><h5><span id="multipart-form-data">multipart/form-data</span><a href="#multipart-form-data" class="header-anchor">#</a></h5><p>参考<a href="https://tools.ietf.org/html/rfc1521">RFC 1521</a></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8afc5ce812624150b78276480c13f799~tplv-k3u1fbpfcp-watermark.image"></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7afcc49efa1b4217a54bbc028eebf646~tplv-k3u1fbpfcp-watermark.image"></p><h4><span id="dai-li-fu-wu-qi-proxy-server">代理服务器(Proxy Server)</span><a href="#dai-li-fu-wu-qi-proxy-server" class="header-anchor">#</a></h4><p><strong>特点</strong>：本身不生成内容，处于中间位置转发上下游的请求和响应</p><ul><li>面向下游的客户端：它是服务器</li><li>面向上游的服务器：它是客户端<h5><span id="zheng-xiang-dai-li-fan-xiang-dai-li">正向代理、反向代理</span><a href="#zheng-xiang-dai-li-fan-xiang-dai-li" class="header-anchor">#</a></h5>正向代理：代理的对象是客户端</li></ul><blockquote><p>作用 </p><ol><li>隐藏客户端身份</li><li>绕过防火墙(突破访问限制)</li><li>Internet访问控制</li><li>数据过滤<br>等等<br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4b1204f7112440496fd8d731c0e8164~tplv-k3u1fbpfcp-watermark.image"></li></ol></blockquote><p>反向代理：代理的对象是服务器 </p><blockquote><p>作用 </p><ol><li>隐藏服务器身份</li><li>安全防护</li><li>负载均衡<br>等等<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/478520a68db94c309b965729885fff16~tplv-k3u1fbpfcp-watermark.image"></li></ol></blockquote><h5><span id="zhua-bao-gong-ju-de-yuan-li">抓包工具的原理</span><a href="#zhua-bao-gong-ju-de-yuan-li" class="header-anchor">#</a></h5><p><code>Fiddler</code>、<code>Charles</code>等抓包工具的原理:在客户端启动了正向代理服务</p><p>需要注意的是<code>Wireshark的</code>原理是:通过底层驱动，拦截网卡上流过的数据</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/262cead9d94a4617a7a1f55a97aa138c~tplv-k3u1fbpfcp-watermark.image"></p><h5><span id="dai-li-fu-wu-qi-xiang-guan-de-tou-bu-zi-duan">代理服务器- 相关的头部字段</span><a href="#dai-li-fu-wu-qi-xiang-guan-de-tou-bu-zi-duan" class="header-anchor">#</a></h5><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f564ea29537048d5b12842f3986de713~tplv-k3u1fbpfcp-watermark.image"></p><h4><span id="cdn">CDN</span><a href="#cdn" class="header-anchor">#</a></h4><p>CDN(Content Delivery Network 或 Content Distribution Network),译为：内容分发网络</p><ul><li>利用最靠近每位用户的服务器</li><li>更快更可靠的将音乐、图片、视频等资源文件(一般是静态资源)传递给用户</li></ul><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ce7b79795e9435b946794c6a0708d87~tplv-k3u1fbpfcp-watermark.image"></p><h5><span id="shi-yong-cdn-qian-hou">使用CDN前后</span><a href="#shi-yong-cdn-qian-hou" class="header-anchor">#</a></h5><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8507248c644b44a99d81a1cd9331e30a~tplv-k3u1fbpfcp-watermark.image"></p><ul><li>CDN运营商在全国、乃至全球的各个大枢纽城市都建立了机房，部署了大量拥有高存储带宽的节点，构建了一个跨运营商、跨地域的专用网络，* * 内容所有者向CDN运营商支付费用，CDN将其内容交付给最终用户</li></ul><p>使用CDN前  </p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e009ec6b4d3472282c460ad763a18be~tplv-k3u1fbpfcp-watermark.image"></p><p>使用CDN后</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed2b0a5d229a4d63a0485f6fa6d08f4e~tplv-k3u1fbpfcp-watermark.image"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0302df0db14846f28631a2045d1f5f87~tplv-k3u1fbpfcp-watermark.image"></p><h4><span id="huan-cun">缓存</span><a href="#huan-cun" class="header-anchor">#</a></h4><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d140b7c3bd0746c2a6da87455f61cb25~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-03-10 下午4.49.42.png"></p><h5><span id="xiang-ying-tou">响应头</span><a href="#xiang-ying-tou" class="header-anchor">#</a></h5><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6b4cfacfcee44b88100e58fccc93fbd~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-03-10 下午4.50.35.png"></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8f6111903584bd58797ebd98c2e26f8~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-03-10 下午4.50.54.png"></p><h5><span id="qing-qiu-tou">请求头</span><a href="#qing-qiu-tou" class="header-anchor">#</a></h5><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/563a3acb98c84fdaa2206fda269a1b6e~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-03-10 下午4.51.23.png"></p><h5><span id="last-modified-vs-etag">Last-Modified <code>VS</code>  ETag</span><a href="#last-modified-vs-etag" class="header-anchor">#</a></h5><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7df4725636747b6ae55b4cc1a59f6fa~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-03-10 下午4.52.44.png"></p><h5><span id="huan-cun-de-shi-yong-liu-cheng">缓存的使用流程</span><a href="#huan-cun-de-shi-yong-liu-cheng" class="header-anchor">#</a></h5><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b99938ea9224a86bfe13f8a19495c80~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-03-10 下午4.53.22.png"></p><p>AFN有缓存机制，AFN会把304作为200进行返回，这就导致了不能返回304的问题，所以我就取消了AFN自动缓存具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; AFN会自动把304也当成200返回了，设置下面会让AFN忽略缓存，从而正确返回304</span><br><span class="line"> [manager.requestSerializer setCachePolicy:NSURLRequestReloadIgnoringLocalCacheData];</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="https">HTTPS</span><a href="#https" class="header-anchor">#</a></h2><p><code>HTTPS (HyperText Transfer Protocol Secure)</code>,译为超文本传输安全协议，常称为<code>HTTP over TLS</code>、<code>HTTP over SSL</code>、<code>HTTP Secure</code></p><p>由网景公司于1994年首次提出</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f70e510711a46d89fbb6e65e74831a4~tplv-k3u1fbpfcp-watermark.image"></p><p><code>HTTPS</code>的默认端口号是<code>443</code>（<code>HTTP</code>是<code>80</code>）</p><p>现在在浏览器上输入 <a href="http://www.baidu.com/">http://www.baidu.com</a><br>会自动重定向到 <a href="https://www.baidu.com/">https://www.baidu.com</a></p><h4><span id="ssl-tls">SSL/TLS</span><a href="#ssl-tls" class="header-anchor">#</a></h4><p><code>HTTPS</code>是在<code>HTTP</code>的基础上使用<code>SSL/TLS</code>来加密报文，对窃听和中间人攻击提供合理的保护<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/846463a81b83415f8156edf76b934338~tplv-k3u1fbpfcp-watermark.image"></p><p><code>SSL/TLS</code> 也可以用在其他的协议上，比如</p><ul><li>FTP + SSL/TLS –&gt; FTPS</li><li>SMTP + SSL/TLS –&gt; SMTPS</li></ul><h5><span id="ding-yi">定义</span><a href="#ding-yi" class="header-anchor">#</a></h5><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f3b62e4f3c0242f5b4623fa25326ae84~tplv-k3u1fbpfcp-watermark.image"></p><h5><span id="ssl-tls-gong-zuo-zai-na-yi-ceng">SSL/TLS - 工作在哪一层</span><a href="#ssl-tls-gong-zuo-zai-na-yi-ceng" class="header-anchor">#</a></h5><p>在应用层和传输层之间</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bd1cdc4e2bd4cbaa303c712da1f38f7~tplv-k3u1fbpfcp-watermark.image"></p><h4><span id="openssl">OpenSSL</span><a href="#openssl" class="header-anchor">#</a></h4><p><code>OpenSSL</code> 是<code> SSL/TLS</code>协议的开源实现，始于1998年，支持<code>windows</code>、<code>Mac</code>、<code>Linux</code>等平台</p><ul><li><code>Linux</code>、<code>Mac</code>一般自带<code>OpenSSL</code></li><li><code>Windows</code>下载安装<a href="https://slproweb.com/products/Win32OpenSSL.html">OpenSSL</a></li></ul><p><strong>常用命令</strong><br>生成私钥、生成公钥</p><ul><li>可以使用OpenSSL构建一套属于自己的CA，自己给自己颁发证书，称为“自签名证书”</li></ul><h4><span id="https-de-cheng-ben">HTTPS的成本</span><a href="#https-de-cheng-ben" class="header-anchor">#</a></h4><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c134389d1924324b270aeca8d096428~tplv-k3u1fbpfcp-watermark.image"></p><h4><span id="https-de-tong-xin-guo-cheng">HTTPS的通信过程</span><a href="#https-de-tong-xin-guo-cheng" class="header-anchor">#</a></h4><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b2c0d65ae624be0ae4fa8a0c894ba61~tplv-k3u1fbpfcp-watermark.image"></p><h4><span id="tls-1-2-de-lian-jie">TLS 1.2的连接</span><a href="#tls-1-2-de-lian-jie" class="header-anchor">#</a></h4><p>针对<code>ECDHE</code>密钥交换算法产生的步骤</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eda429a13eb94d3ba5f1b6680db1794e~tplv-k3u1fbpfcp-watermark.image"></p><p><strong>TLS 1.2的连接 - ①</strong><br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71fddd18c8be4916b9d2ba29cb16d781~tplv-k3u1fbpfcp-watermark.image"></p><p><strong>TLS 1.2的连接 - ②</strong><br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5caf4c710ce4c0096f4c8f452dcf725~tplv-k3u1fbpfcp-watermark.image"></p><p><strong>TLS 1.2的连接 - ③</strong><br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a45d7d93233641ccb2bf20d9599dc1b9~tplv-k3u1fbpfcp-watermark.image"></p><p><strong>TLS 1.2的连接 - ④</strong><br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb2dbd47855040be9d4bc99f5b9be6fa~tplv-k3u1fbpfcp-watermark.image"><br><strong>TLS 1.2的连接 - ⑤</strong><br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cbdcc4fb5c7943d4a445e3bce45ecb0a~tplv-k3u1fbpfcp-watermark.image"></p><p><strong>TLS 1.2的连接 - ⑥</strong><br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/908c62de3c734740ba981c6ede15fb14~tplv-k3u1fbpfcp-watermark.image"></p><p><strong>TLS 1.2的连接 - ⑦</strong><br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61c5d40f91814841b0bc5322f431c027~tplv-k3u1fbpfcp-watermark.image"></p><p><strong>TLS 1.2的连接 - ⑧</strong><br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa731244247f419ca5ba303068661c89~tplv-k3u1fbpfcp-watermark.image"></p><p><strong>TLS 1.2的连接 - ⑨、⑩</strong><br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b100d385d7c848429affd6995b20ad39~tplv-k3u1fbpfcp-watermark.image"></p><h4><span id="https-qing-qiu">HTTPS请求</span><a href="#https-qing-qiu" class="header-anchor">#</a></h4><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b3ad3f92a884ddc906ed7d38f0aee04~tplv-k3u1fbpfcp-watermark.image"></p><h2><span id="http-2-0-3-0">HTTP 2.0 / 3.0</span><a href="#http-2-0-3-0" class="header-anchor">#</a></h2><h4><span id="http-xie-yi-de-bu-zu-http-1-1">HTTP 协议的不足(HTTP/1.1)</span><a href="#http-xie-yi-de-bu-zu-http-1-1" class="header-anchor">#</a></h4><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45e599e452e3436f9aa46e06c4b70ab8~tplv-k3u1fbpfcp-watermark.image"></p><h4><span id="spdy">SPDY</span><a href="#spdy" class="header-anchor">#</a></h4><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45d965dfb90a479c9e01c380c35db3e6~tplv-k3u1fbpfcp-watermark.image"></p><h4><span id="http-2">HTTP/2</span><a href="#http-2" class="header-anchor">#</a></h4><ul><li><p>HTTP/2，于2015年5月以<a href="https://tools.ietf.org/html/rfc7540">RFC 7540</a>正式发表 (根据W3Techs的数据，截至2019年6月，全球有36.5%的网站支持了HTTP/2)</p></li><li><p>HTTP/1.1 和 HTTP/2 速度对比<br><a href="http://www.http2demo.io/">http://www.http2demo.io</a><br><a href="https://http2.akamai.com/demo">https://http2.akamai.com/demo</a></p></li><li><p>HTTP/2 在底层传输做了很多的改进和优化，但在语意上完全与HTTP/1.1兼容</p><ul><li>比如请求方法(如GET、POST)、Status Code、各种Headers等都没有改变</li><li>因此，要想升级到HTTP/2，开发者不需要修改任何代码，只需要升级服务器配置、升级浏览器</li><li>iOS的网络请求由<code>NSURLConnection</code>替换到了支持HTTP/2的<code>NSURLSession</code></li></ul></li></ul><h5><span id="http-2-de-te-xing-er-jin-zhi-ge-shi">HTTP/2的特性 - 二进制格式</span><a href="#http-2-de-te-xing-er-jin-zhi-ge-shi" class="header-anchor">#</a></h5><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec5f35b8a95049bf8924a83e52421fcb~tplv-k3u1fbpfcp-watermark.image"></p><ul><li>HTTP/2采用二进制格式传输数据，而非HTTP/1.1的文本格式</li><li>二进制格式在协议的解析和优化扩展上带来了更多的优势和可能</li></ul><h5><span id="yi-xie-ji-ben-gai-nian">一些基本概念</span><a href="#yi-xie-ji-ben-gai-nian" class="header-anchor">#</a></h5><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d3951d937a142d1b37807f59d108589~tplv-k3u1fbpfcp-watermark.image"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/902547a36c25487b9f7991315c77aa87~tplv-k3u1fbpfcp-watermark.image"></p><h5><span id="http-2-de-te-xing-duo-lu-fu-yong-multiplexing">HTTP/2的特性 - 多路复用(Multiplexing)</span><a href="#http-2-de-te-xing-duo-lu-fu-yong-multiplexing" class="header-anchor">#</a></h5><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de47403895f846d993e740b56d7586fb~tplv-k3u1fbpfcp-watermark.image"></p><p><strong>image Sprites</strong></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d760fb22ca543799cd3441756935cf4~tplv-k3u1fbpfcp-watermark.image"></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a67513cf3f5149468986cfac38fa9592~tplv-k3u1fbpfcp-watermark.image"></p><h5><span id="http-2-de-te-xing-you-xian-ji">HTTP/2的特性 - 优先级</span><a href="#http-2-de-te-xing-you-xian-ji" class="header-anchor">#</a></h5><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a62f5b2931114291ab771188a91ed5d2~tplv-k3u1fbpfcp-watermark.image"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d5efd2f2c7d4596819733c35680e001~tplv-k3u1fbpfcp-watermark.image"></p><h5><span id="http-2-de-te-xing-tou-bu-ya-suo">HTTP/2的特性 - 头部压缩</span><a href="#http-2-de-te-xing-tou-bu-ya-suo" class="header-anchor">#</a></h5><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2324c0f1c41c4bb9aad20586cf4b3b2f~tplv-k3u1fbpfcp-watermark.image"></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56b62d0bd2234c06be89a56a89bc969a~tplv-k3u1fbpfcp-watermark.image"></p><h5><span id="http-2-de-te-xing-fu-wu-qi-tui-song-sever-push">HTTP/2的特性 - 服务器推送（Sever Push）</span><a href="#http-2-de-te-xing-fu-wu-qi-tui-song-sever-push" class="header-anchor">#</a></h5><blockquote><p>注意： 还是要客户端率先发起请求</p></blockquote><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb20cc8361734e6c983650ab9c32f226~tplv-k3u1fbpfcp-watermark.image"></p><h5><span id="http-2-de-wen-ti-dui-tou-du-sai-head-of-line-blocking">HTTP/2 的问题 - 队头堵塞(head of line blocking)</span><a href="#http-2-de-wen-ti-dui-tou-du-sai-head-of-line-blocking" class="header-anchor">#</a></h5><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5938a724211941d99aa2cf8efd3db272~tplv-k3u1fbpfcp-watermark.image"></p><h5><span id="http-2-de-wen-ti-wo-shou-yan-chi">HTTP/2 的问题 - 握手延迟</span><a href="#http-2-de-wen-ti-wo-shou-yan-chi" class="header-anchor">#</a></h5><p>RTT (Round Trip Time)：往返时延，可以简单理解为通信一来一回的时间</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb3e2d3048344682a039b7da348287f6~tplv-k3u1fbpfcp-watermark.image"></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b2c5918dc1864a949432599ca8be1f89~tplv-k3u1fbpfcp-watermark.image"></p><h4><span id="http-3">HTTP/3</span><a href="#http-3" class="header-anchor">#</a></h4><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60b83717fbfc42fdb0ea22e3755328e4~tplv-k3u1fbpfcp-watermark.image"></p><h5><span id="http-3-yi-wen">HTTP/3 - 疑问</span><a href="#http-3-yi-wen" class="header-anchor">#</a></h5><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3fcf61143704f3fb21ed0b3f7201b38~tplv-k3u1fbpfcp-watermark.image"></p><h5><span id="http-3-de-te-xing-lian-jie-qian-yi">HTTP/3的特性 - 连接迁移</span><a href="#http-3-de-te-xing-lian-jie-qian-yi" class="header-anchor">#</a></h5><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/178c84dbfe2745edaedfe91563bf7523~tplv-k3u1fbpfcp-watermark.image"></p><h5><span id="http-3-de-wen-ti-cao-zuo-xi-tong-nei-he-cpu-fu-zai">HTTP/3的问题 - 操作系统内核、CPU负载</span><a href="#http-3-de-wen-ti-cao-zuo-xi-tong-nei-he-cpu-fu-zai" class="header-anchor">#</a></h5><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37c2b6acaa5f4871979a963e262781f5~tplv-k3u1fbpfcp-watermark.image"></p><h2><span id="qi-ta-xie-yi">其他协议</span><a href="#qi-ta-xie-yi" class="header-anchor">#</a></h2><h4><span id="http-vs-websocket">HTTP VS WebSocket</span><a href="#http-vs-websocket" class="header-anchor">#</a></h4><p><strong>HTTP</strong></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a640f7bbb3f642d78531c4f431e8a419~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-03-10 下午5.15.31.png"></p><p><strong>WebSocket</strong><br><code>webSocket</code> 跟 <code>Socket</code>是两码事，<code>Socket</code>是系统底层的网络请求框架，提供网络请求的<code>API</code>，我们用的<code>NSURLSession</code>等都是进行的封装，<code>webSocket</code>是个应用层协议</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9d6d01b4be84bce99c6549ff664bc7c~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-03-10 下午5.17.33.png"></p><p><strong>HTTP</strong> VS <strong>WebSocket</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2bcd69a874c14990904a024e3bf0bc73~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-03-10 下午5.21.04.png"></p><h5><span id="websocket-jian-li-lian-jie">WebSocket - 建立连接</span><a href="#websocket-jian-li-lian-jie" class="header-anchor">#</a></h5><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a917600e5444f3c9578a09d2c6b2164~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-03-10 下午5.22.02.png"></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c7a40be28b64781a75f9e13bd538b0d~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-03-10 下午5.22.16.png"></p><ul><li><a href="https://www.websocket.org/echo.html">WebSocket体验和演示</a></li></ul><h4><span id="httpdns">HTTPDNS</span><a href="#httpdns" class="header-anchor">#</a></h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc6be47bb703461f85d9a435acf2c067~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-03-10 下午5.24.43.png"></p><ul><li>市面上已经有现成的解决方案 腾讯云、阿里云，移动端集成相关的SDK即可使用HTTPDNS服务</li></ul><h4><span id="ftp">FTP</span><a href="#ftp" class="header-anchor">#</a></h4><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1421fe69b4f54c7d98d9834882b2bb20~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-03-10 下午5.26.18.png"></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f96f486d403497c9f213f3009e8f3d6~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-03-10 下午5.26.42.png"></p><p><strong>主动模式</strong></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4ba2f5020d247a49f1042626ca596e8~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-03-10 下午5.27.28.png"></p><p><strong>被动模式</strong></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8ede24f65694b8c99d594535106e6e5~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-03-10 下午5.28.02.png"></p><h4><span id="you-jian-xiang-guan-de-xie-yi">邮件相关的协议</span><a href="#you-jian-xiang-guan-de-xie-yi" class="header-anchor">#</a></h4><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc887ea107e3464e948ec4402bb0caed~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-03-10 下午5.28.36.png"></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8382320a4e7b4b668e0302a68dcd27c6~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-03-10 下午5.28.56.png"></p><h5><span id="pop-vs-imap">POP vs IMAP</span><a href="#pop-vs-imap" class="header-anchor">#</a></h5><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4e6d71e5ff642e9a4d0510b980cbb4b~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-03-10 下午5.29.39.png"></p><h4><span id="ipv6">IPv6</span><a href="#ipv6" class="header-anchor">#</a></h4><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/120dfc799dbe4e46a77fe2a0d6d094b6~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-03-10 下午5.30.22.png"></p><h5><span id="di-zhi-ge-shi">地址格式</span><a href="#di-zhi-ge-shi" class="header-anchor">#</a></h5><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04564e27a6e2478abe00edb4c9bf64c2~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-03-10 下午5.30.51.png"></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c18ba253505b44888ec8b726acb83c6b~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-03-10 下午5.31.08.png"></p><h5><span id="shou-bu-ge-shi">首部格式</span><a href="#shou-bu-ge-shi" class="header-anchor">#</a></h5><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9174fd2904f24282a3c3acc2fdd63a2c~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-03-10 下午5.31.41.png"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d54352c729d419aa5831bf11aba7116~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-03-10 下午5.31.58.png"></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81e5dacba9f647de8984f6449899fd60~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-03-10 下午5.32.26.png"></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c056b84f4f354fb1bd1ed6fbb2e92f31~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-03-10 下午5.32.43.png"></p><h5><span id="kuo-zhan-tou-bu">扩展头部</span><a href="#kuo-zhan-tou-bu" class="header-anchor">#</a></h5><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f6a2b6aeb9f43a1836362ac1576740b~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-03-10 下午5.33.09.png"></p><p>这里<code>Next Header</code>指出的是下一个扩展头部的内容，而不是地址，因为地址就是顺次挨着的，不需要指出</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fea4c31a3284d108d916aa7577413ca~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-03-10 下午5.33.59.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;ying-yong-ceng&quot;&gt;应用层&lt;/span&gt;&lt;a href=&quot;#ying-yong-ceng&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span id=&quot;ji-chu-gai-nian&quot;&gt;基础概念&lt;/span&gt;</summary>
      
    
    
    
    
    <category term="网络" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
