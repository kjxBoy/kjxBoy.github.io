<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>底层六：runLoop · Hexo</title><meta name="description" content="在 LLDB 中 打印 bt 就可以打印函数调用栈
RunLoop源码
简介#RunLoop：运行循环概念：  一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出
应用范畴：#12345定时器（Timer）、PerformSelect"><meta name="keywords" content=""><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="stage" class="container"><div class="row"><div id="side-bar" class="col-sm-3 col-xs-12 side-container invisible"><div class="vertical-text site-title"><h3 tabindex="-1" class="site-title-small"><a href="/" class="a-title">生活</a></h3><h1 tabindex="-1" class="site-title-large"><a href="/" class="a-title">聊聊</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div id="site-nav" class="site-title-links"><ul><li><a href="/">Home</a></li><li><a href="/archives">Archive</a></li><li><a href="/tags">Tags</a></li><li><a href="/tags/index.html"></a></li><li class="soc"><a href="http://example.com/atom.xml" target="_blank" rel="noopener noreferrer"><i class="fa fa-rss">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2021&nbsp;<a target="_blank" href="http://example.com" rel="noopener noreferrer">John Doe</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div><div id="main-container" class="col-sm-9 col-xs-12 main-container invisible"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>底层六：runLoop</a></p><p class="post-meta"><span class="date meta-item">Posted at&nbsp;2021-03-08</span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a href="/tags/底层/" title="底层" class="a-tag">底层</a><span>&nbsp;</span></span></p><p class="post-abstract"><p>在 <code>LLDB</code> 中 打印 <code>bt</code> 就可以打印函数调用栈</p>
<p><a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/CF/">RunLoop源码</a></p>
<h4><span id="jian-jie">简介</span><a href="#jian-jie" class="header-anchor">#</a></h4><p><code>RunLoop：</code>运行循环<br><code>概念：</code>  一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能<code>随时处理事件但并不退出</code></p>
<h5><span id="ying-yong-fan-chou">应用范畴：</span><a href="#ying-yong-fan-chou" class="header-anchor">#</a></h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">定时器（Timer）、PerformSelector</span><br><span class="line">GCD Async Main Queue</span><br><span class="line">事件响应、手势识别、界面刷新</span><br><span class="line">网络请求</span><br><span class="line">AutoreleasePool</span><br></pre></td></tr></table></figure>
<p><strong>如果没有运行循环的情况下</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// insert code here...</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Hello, World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在执行了第5行代码后，程序会自动退出</span></span><br></pre></td></tr></table></figure>
<p><strong>如果有了运行循环</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 程序并不会马上退出，而是保持运行状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> retVal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 睡眠中等待消息</span></span><br><span class="line">            <span class="keyword">int</span> message = sleep_and_wait();</span><br><span class="line">            <span class="comment">// 处理消息</span></span><br><span class="line">            retVal = process_message(message);</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="number">0</span> == retVal) ;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5><span id="runloop-de-ji-ben-zuo-yong">RunLoop的基本作用</span><a href="#runloop-de-ji-ben-zuo-yong" class="header-anchor">#</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">保持程序的持续运行</span><br><span class="line">处理App中的各种事件（比如触摸事件、定时器事件等）</span><br><span class="line">节省CPU资源，提高程序性能：该做事时做事，该休息时休息</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<h4><span id="runloop-dui-xiang">Runloop对象</span><a href="#runloop-dui-xiang" class="header-anchor">#</a></h4><p><strong>iOS 中有两套API来访问和使用RunLoop</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Foundation：<span class="built_in">NSRunLoop</span></span><br><span class="line">Core Foundation：<span class="built_in">CFRunLoopRef</span></span><br></pre></td></tr></table></figure>

<p><code>NSRunLoop</code>和<code>CFRunLoopRef</code>都代表着<code>RunLoop</code>对象<br><code>NSRunLoop</code>是基于<code>CFRunLoopRef</code>的一层OC包装<br><code>CFRunLoopRef</code>是<a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/CF/">开源</a>的</p>
<h4><span id="runloop-yu-xian-cheng">RunLoop与线程</span><a href="#runloop-yu-xian-cheng" class="header-anchor">#</a></h4><blockquote>
<ul>
<li><code>每条线程</code>都有<code>唯一</code>的一个与之对应的<code>RunLoop</code>对象</li>
<li> <code>RunLoop</code>保存在一个<code>全局的Dictionary</code>里，线程作为<code>key</code>，<code>RunLoop</code>作为<code>value</code></li>
<li> 线程刚创建时并没有<code>RunLoop</code>对象，<code>RunLoop</code>会在第一次获取它时创建</li>
<li> <code>RunLoop</code>会在线程结束时销毁</li>
<li> 主线程的<code>RunLoop</code>已经自动获取（创建），子线程默认没有开启<code>RunLoop</code></li>
</ul>
</blockquote>
<p><strong>获取RunLoop对象</strong><br><code>Foundation</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">NSRunLoop</span> currentRunLoop]; <span class="comment">// 获得当前线程的RunLoop对象</span></span><br><span class="line">[<span class="built_in">NSRunLoop</span> mainRunLoop]; <span class="comment">// 获得主线程的RunLoop对象</span></span><br></pre></td></tr></table></figure>

<p><code>Core Foundation</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFRunLoopGetCurrent</span>(); <span class="comment">// 获得当前线程的RunLoop对象</span></span><br><span class="line"><span class="built_in">CFRunLoopGetMain</span>(); <span class="comment">// 获得主线程的RunLoop对象</span></span><br></pre></td></tr></table></figure>

<p><strong>打印</strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%p %p&quot;</span>, [<span class="built_in">NSRunLoop</span> mainRunLoop], [<span class="built_in">NSRunLoop</span> currentRunLoop]);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%p %p&quot;</span>, <span class="built_in">CFRunLoopGetMain</span>(), <span class="built_in">CFRunLoopGetCurrent</span>());    </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,[<span class="built_in">NSRunLoop</span> mainRunLoop]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0x60000069aa60 0x60000069aa60</span></span><br><span class="line"><span class="comment">// 0x600001e98d00 0x600001e98d00</span></span><br><span class="line"><span class="comment">// &lt;CFRunLoop 0x600001e98d00 [0x10eeefb68]&gt;</span></span><br></pre></td></tr></table></figure>
<p> 通过打印结果可以看出，<code>NSRunLoop</code>对象是基于<code>CFRunLoop</code>的一层封装</p>
<h4><span id="mode">Mode</span><a href="#mode" class="header-anchor">#</a></h4><h5><span id="source0">source0</span><a href="#source0" class="header-anchor">#</a></h5><ul>
<li>处理<code>触摸</code>事件<br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a51717b0e4184e54b9d39aa313228901~tplv-k3u1fbpfcp-watermark.image"></li>
</ul>
<ul>
<li>处理 <code>performSelector:onThread:withObject:waitUntilDone:</code>和<code>performSelector:onThread:withObject:waitUntilDone:modes:</code>事件<br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc84515ea71b4d5db16c01fb7817e812~tplv-k3u1fbpfcp-watermark.image"></li>
</ul>
<h5><span id="source1">source1</span><a href="#source1" class="header-anchor">#</a></h5><ul>
<li>基于<code>port</code>的线程间通信</li>
<li>系统事件的捕捉（触摸事件是<code>source1</code>捕捉，包装成<code>source0</code>处理）</li>
</ul>
<h5><span id="timer">Timer</span><a href="#timer" class="header-anchor">#</a></h5><ul>
<li><code>NSTimer</code></li>
<li><code>performSelector:withObject:afterDelay:</code></li>
</ul>
<h5><span id="observers">Observers</span><a href="#observers" class="header-anchor">#</a></h5><ul>
<li>用于监听<code>runLoop</code>状态</li>
<li>UI刷新(<code>beforeWaiting</code>)</li>
<li>Autorelease Pool</li>
</ul>
<h5><span id="runloop-xiang-guan-de-lei">RunLoop相关的类</span><a href="#runloop-xiang-guan-de-lei" class="header-anchor">#</a></h5><p><code>Core Foundation</code>中关于<code>RunLoop</code>的5个类</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFRunLoopRef</span></span><br><span class="line"><span class="built_in">CFRunLoopModeRef</span></span><br><span class="line"><span class="built_in">CFRunLoopSourceRef</span></span><br><span class="line"><span class="built_in">CFRunLoopTimerRef</span></span><br><span class="line"><span class="built_in">CFRunLoopObserverRef</span></span><br></pre></td></tr></table></figure>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd56df84d8d5461793f8771a64524c10~tplv-k3u1fbpfcp-zoom-1.image" alt="图片 1.png"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65827269ad944cc4982c55d0bbb105b0~tplv-k3u1fbpfcp-zoom-1.image" alt="图片 2.png"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d2553b2a2914cf8af6cbe94ba06653c~tplv-k3u1fbpfcp-zoom-1.image" alt="图片 3.png"></p>
<blockquote>
<ul>
<li> <code>CFRunLoopModeRef</code>代表<code>RunLoop</code>的运行模式</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li> 一个<code>RunLoop</code>包含若干个<code>Mode</code>，每个<code>Mode</code>又包含若干个<code>Source0/Source1/Timer/Observer</code></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li> <code>RunLoop</code>启动时只能选择其中一个<code>Mode</code>，作为<code>currentMode</code></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>如果需要切换<code>Mode</code>，只能退出<code>当前Loop</code>，再重新选择一个<code>Mode</code>进入<br> ———&gt; 不同组的<code>Source0/Source1/Timer/Observer</code>能分隔开来，互不影响</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li> 如果<code>Mode</code>里没有任何<code>Source0/Source1/Timer/Observer</code>，<code>RunLoop</code>会立马退出</li>
</ul>
</blockquote>
<h5><span id="cfrunloopmoderef">CFRunLoopModeRef</span><a href="#cfrunloopmoderef" class="header-anchor">#</a></h5><p><strong>常见的2种Mode</strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kCFRunLoopDefaultMode（<span class="built_in">NSDefaultRunLoopMode</span>）：App的默认Mode，通常主线程是在这个Mode下运行</span><br><span class="line"><span class="built_in">UITrackingRunLoopMode</span>：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响</span><br></pre></td></tr></table></figure>

<h5><span id="cfrunloopobserverref-runloop-de-liu-chong-zhuang-tai">CFRunLoopObserverRef (runLoop的六种状态)</span><a href="#cfrunloopobserverref-runloop-de-liu-chong-zhuang-tai" class="header-anchor">#</a></h5><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c748dd15f564f8db79908c83977baf8~tplv-k3u1fbpfcp-zoom-1.image" alt="图片 4.png"></p>
<p><strong>添加Observer监听RunLoop的所有状态</strong><br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/683117188fea4da19212c84f3c0f932f~tplv-k3u1fbpfcp-zoom-1.image" alt="图片 5.png"></p>
<p><strong>监听Mode的转变</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Observer</span></span><br><span class="line">    <span class="built_in">CFRunLoopObserverRef</span> observer = <span class="built_in">CFRunLoopObserverCreateWithHandler</span>(kCFAllocatorDefault, kCFRunLoopAllActivities, <span class="literal">YES</span>, <span class="number">0</span>, ^(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (activity) &#123;</span><br><span class="line">            <span class="keyword">case</span> kCFRunLoopEntry: &#123;</span><br><span class="line">                <span class="built_in">CFRunLoopMode</span> mode = <span class="built_in">CFRunLoopCopyCurrentMode</span>(<span class="built_in">CFRunLoopGetCurrent</span>());</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopEntry - %@&quot;</span>, mode);</span><br><span class="line">                <span class="built_in">CFRelease</span>(mode);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">case</span> kCFRunLoopExit: &#123;</span><br><span class="line">                <span class="built_in">CFRunLoopMode</span> mode = <span class="built_in">CFRunLoopCopyCurrentMode</span>(<span class="built_in">CFRunLoopGetCurrent</span>());</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopExit - %@&quot;</span>, mode);</span><br><span class="line">                <span class="built_in">CFRelease</span>(mode);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// kCFRunLoopCommonModes默认包括kCFRunLoopDefaultMode、UITrackingRunLoopMode</span></span><br><span class="line">    <span class="comment">// 添加Observer到RunLoop中</span></span><br><span class="line">    <span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopGetMain</span>(), observer, kCFRunLoopCommonModes);</span><br><span class="line">    <span class="comment">// 释放</span></span><br><span class="line">    <span class="built_in">CFRelease</span>(observer);</span><br></pre></td></tr></table></figure>

<h4><span id="runloop-de-yun-xing-luo-ji">RunLoop的运行逻辑</span><a href="#runloop-de-yun-xing-luo-ji" class="header-anchor">#</a></h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7839915fcef64bc99df463f52c724eda~tplv-k3u1fbpfcp-zoom-1.image" alt="图片 6.png"></p>
<table>
<thead>
<tr>
<th align="left"><code>Mode</code>类型</th>
<th align="right"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Source0</code></td>
<td align="right">触摸事件处理</td>
<td align="center">performSelector:onThread:</td>
<td align="center"></td>
</tr>
<tr>
<td align="left"><code>Source1</code></td>
<td align="right">基于Port的线程间通信</td>
<td align="center">系统事件捕捉</td>
<td align="center"></td>
</tr>
<tr>
<td align="left"><code>Timers</code></td>
<td align="right">NSTimer</td>
<td align="center">performSelector:withObject:afterDelay:</td>
<td align="center"></td>
</tr>
<tr>
<td align="left"><code>Observers</code></td>
<td align="right">用于监听RunLoop的状态</td>
<td align="center">UI刷新（BeforeWaiting）</td>
<td align="center">Autorelease pool（BeforeWaiting）</td>
</tr>
</tbody></table>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/056c40992cd749cb8408e661d84a7ff0~tplv-k3u1fbpfcp-zoom-1.image" alt="图片 7.png"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0073edaae3b45b499dd849cd0331446~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h5><span id="runloop-xiu-mian-de-shi-xian-yuan-li">RunLoop休眠的实现原理</span><a href="#runloop-xiu-mian-de-shi-xian-yuan-li" class="header-anchor">#</a></h5><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d466342e66542d1970e245f4e20d5ed~tplv-k3u1fbpfcp-zoom-1.image" alt="图片 8.png"></p>
<h5><span id="runloop-zai-shi-ji-kai-zhong-de-ying-yong">RunLoop在实际开中的应用</span><a href="#runloop-zai-shi-ji-kai-zhong-de-ying-yong" class="header-anchor">#</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">控制线程生命周期（线程保活）</span><br><span class="line">解决NSTimer在滑动时停止工作的问题</span><br><span class="line">监控应用卡顿</span><br><span class="line">性能优化</span><br></pre></td></tr></table></figure>

<p>补充：</p>
<p><code>GCD</code>很多东西是不依赖<code>RunLoop</code>的，<code>GCD</code>执行流程是与<code>RunLoop</code>是分开的，但是<code>GCD</code>有一种情况是交给<code>RunLoop</code>处理就是<code>线程间通信</code></p>
<p><code>NSTimer失效</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">1.0</span> repeats:<span class="literal">YES</span> block:^(<span class="built_in">NSTimer</span> * _Nonnull timer) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>, ++count);</span><br><span class="line">    &#125;];</span><br><span class="line"><span class="comment">//    [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];</span></span><br><span class="line"><span class="comment">//    [[NSRunLoop currentRunLoop] addTimer:timer forMode:UITrackingRunLoopMode];</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// NSDefaultRunLoopMode、UITrackingRunLoopMode才是真正存在的模式</span></span><br><span class="line">    <span class="comment">// NSRunLoopCommonModes并不是一个真的模式，它只是一个标记</span></span><br><span class="line">    <span class="comment">// timer能在_commonModes数组中存放的模式下工作</span></span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br></pre></td></tr></table></figure>

<h4><span id="runloop-de-ying-yong">RunLoop的应用</span><a href="#runloop-de-ying-yong" class="header-anchor">#</a></h4><h5><span id="chu-li-nstimer-he-uiscrollview-de-chong-tu">处理<code>NSTimer</code>和<code>UIScrollView</code>的冲突</span><a href="#chu-li-nstimer-he-uiscrollview-de-chong-tu" class="header-anchor">#</a></h5><h5><span id="xian-cheng-bao-huo">线程保活</span><a href="#xian-cheng-bao-huo" class="header-anchor">#</a></h5><blockquote>
<p><code>warning：</code> 一般<code>initWithTarget：</code>容易造成循环引用</p>
</blockquote>
<p><code>NSRunLoop</code>的<code>run</code>方法，用于开启<code>无限循环</code>的线程</p>
<p>使用懒加载的时候一定要注意的情况：当<code>_thread</code>是懒加载时</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!_thread) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>

<p>如果写成</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.thread) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
<p>会造成循环引用</p>
</p></div><div class="share"><span>Share</span>&nbsp;<span class="soc"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></span><span class="soc"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></span><span class="soc"><a target="_blank" rel="noopener" href="http://twitter.com/home?status=http://example.com/2021/03/08/底层六：runLoop/%20Hexo%20底层六：runLoop" class="fa fa-twitter"></a></span></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/2021/03/08/%E5%BA%95%E5%B1%82%E4%BA%8C%EF%BC%9AKVO%E3%80%81KVC/" title="底层二：KVO、KVC"><i class="fa fa-angle-double-left"></i>&nbsp;Previous post: 底层二：KVO、KVC</a></span><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/2021/03/08/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/" title="网络安全">Next post: 网络安全&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2021&nbsp;<a target="_blank" href="http://example.com" rel="noopener noreferrer">John Doe</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script></body></html>