<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>底层三：Category · Hexo</title><meta name="description" content="category#category中的方法是通过runtime动态的将分类的方法合并到类对象、元类对象中
最后面参与编译的分类，方法的实现在最前面
category 的底层CPP结构是 _category_t，一个分类对应一个结构体对象，然后通过runtime将方法合并到类对象中
123456789"><meta name="keywords" content=""><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="stage" class="container"><div class="row"><div id="side-bar" class="col-sm-3 col-xs-12 side-container invisible"><div class="vertical-text site-title"><h3 tabindex="-1" class="site-title-small"><a href="/" class="a-title">生活</a></h3><h1 tabindex="-1" class="site-title-large"><a href="/" class="a-title">聊聊</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div id="site-nav" class="site-title-links"><ul><li><a href="/">Home</a></li><li><a href="/archives">Archive</a></li><li><a href="/tags">Tags</a></li><li><a href="/tags/index.html"></a></li><li class="soc"><a href="http://example.com/atom.xml" target="_blank" rel="noopener noreferrer"><i class="fa fa-rss">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2021&nbsp;<a target="_blank" href="http://example.com" rel="noopener noreferrer">John Doe</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div><div id="main-container" class="col-sm-9 col-xs-12 main-container invisible"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>底层三：Category</a></p><p class="post-meta"><span class="date meta-item">Posted at&nbsp;2021-03-08</span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a href="/tags/底层/" title="底层" class="a-tag">底层</a><span>&nbsp;</span></span></p><p class="post-abstract"><h4><span id="category">category</span><a href="#category" class="header-anchor">#</a></h4><p><code>category</code>中的方法是通过<code>runtime</code>动态的将分类的方法合并到类对象、元类对象中</p>
<p><strong>最后面参与编译的分类，方法的实现在最前面</strong></p>
<p><code>category</code> 的底层CPP结构是 <code>_category_t</code>，一个分类对应一个结构体对象，然后通过runtime将方法合并到类对象中</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;MJPerson.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MJPerson</span> (<span class="title">Eat</span>) &lt;<span class="title">NSCopying</span>, <span class="title">NSCoding</span>&gt;</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)eat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="keyword">int</span> weight;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="keyword">double</span> height;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .m</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;MJPerson+Eat.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MJPerson</span> (<span class="title">Eat</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)run</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;MJPerson (Eat) - run&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)eat</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;eat&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)eat1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;eat1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)eat2</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)eat3</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>转换后</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">category_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">// 类名</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">class_t</span> *<span class="title">cls</span>;</span> <span class="comment">//</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">method_list_t</span> *<span class="title">instance_methods</span>;</span> <span class="comment">// 对象方法</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">method_list_t</span> *<span class="title">class_methods</span>;</span>   <span class="comment">//  类方法</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span>   <span class="comment">//  协议</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">prop_list_t</span> *<span class="title">properties</span>;</span>   <span class="comment">//  属性</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">利用结构体创建出一个对象 OBJC_$_CATEGORY_MJPerson_$_Eat</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> _<span class="title">category_t</span> _<span class="title">OBJC_</span>$_<span class="title">CATEGORY_MJPerson_</span>$_<span class="title">Eat</span> __<span class="title">attribute__</span> ((<span class="title">used</span>, <span class="title">section</span> (&quot;__<span class="title">DATA</span>,__<span class="title">objc_const</span>&quot;))) =</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;MJPerson&quot;</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="comment">// &amp;OBJC_CLASS_$_MJPerson,</span></span><br><span class="line">    (<span class="keyword">const</span> struct <span class="keyword">_method_list_t</span> *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_MJPerson_$_Eat,</span><br><span class="line">    (<span class="keyword">const</span> struct <span class="keyword">_method_list_t</span> *)&amp;_OBJC_$_CATEGORY_CLASS_METHODS_MJPerson_$_Eat,</span><br><span class="line">    (<span class="keyword">const</span> struct <span class="keyword">_protocol_list_t</span> *)&amp;_OBJC_CATEGORY_PROTOCOLS_$_MJPerson_$_Eat,</span><br><span class="line">    (<span class="keyword">const</span> struct <span class="keyword">_prop_list_t</span> *)&amp;_OBJC_$_PROP_LIST_MJPerson_$_Eat,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这些是不同的结构体，去转换后的代码里看</span></span><br><span class="line">_OBJC_$_CATEGORY_INSTANCE_METHODS_MJPerson_$_Eat </span><br><span class="line">_OBJC_$_CATEGORY_CLASS_METHODS_MJPerson_$_Eat</span><br><span class="line">…… …… …… </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里要通过转换后的CPP代码去看，编译完成后，<code>类名、对象方法、类方法、协议、属性</code> 存放到了结构体 <code>_category_t</code> 底层结构中，并没有合并到<code>类对象</code>中，在程序运行时，runtime会将category的数据，合并到类对象(元类对象)中</p>
<p>分类的加载处理过程</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b1670ec3e2c4a79b6c25998b95f791c~tplv-k3u1fbpfcp-watermark.image" alt="01-OC语法.png"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d46a1a2164394469a47017e32c004e37~tplv-k3u1fbpfcp-zoom-1.image" alt="category"></p>
<ul>
<li><p>后面参与<code>编译</code>的<code>Category</code>数据，会在数组的前面(优先调用)</p>
</li>
<li><p>使用<code>msg_send</code>发送消息的调用顺序<code>1.分类  2.父类</code> （比对子类和父类没有意义）</p>
</li>
</ul>
<h4><span id="load-fang-fa">+load方法</span><a href="#load-fang-fa" class="header-anchor">#</a></h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* call_load_methods</span></span><br><span class="line"><span class="comment">* Call all pending class and category +load methods.</span></span><br><span class="line"><span class="comment">* Class +load methods are called superclass-first. </span></span><br><span class="line"><span class="comment">* Category +load methods are not called until after the parent class&#x27;s +load.</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* This method must be RE-ENTRANT, because a +load could trigger </span></span><br><span class="line"><span class="comment">* more image mapping. In addition, the superclass-first ordering </span></span><br><span class="line"><span class="comment">* must be preserved in the face of re-entrant calls. Therefore, </span></span><br><span class="line"><span class="comment">* only the OUTERMOST call of this function will do anything, and </span></span><br><span class="line"><span class="comment">* that call will handle all loadable classes, even those generated </span></span><br><span class="line"><span class="comment">* while it was running.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* The sequence below preserves +load ordering in the face of </span></span><br><span class="line"><span class="comment">* image loading during a +load, and make sure that no </span></span><br><span class="line"><span class="comment">* +load method is forgotten because it was added during </span></span><br><span class="line"><span class="comment">* a +load call.</span></span><br><span class="line"><span class="comment">* Sequence:</span></span><br><span class="line"><span class="comment">* 1. Repeatedly call class +loads until there aren&#x27;t any more</span></span><br><span class="line"><span class="comment">* 2. Call category +loads ONCE.</span></span><br><span class="line"><span class="comment">* 3. Run more +loads if:</span></span><br><span class="line"><span class="comment">*    (a) there are more classes to load, OR</span></span><br><span class="line"><span class="comment">*    (b) there are some potential category +loads that have </span></span><br><span class="line"><span class="comment">*        still never been attempted.</span></span><br><span class="line"><span class="comment">* Category +loads are only run once to ensure &quot;parent class first&quot; </span></span><br><span class="line"><span class="comment">* ordering, even if a category +load triggers a new loadable class </span></span><br><span class="line"><span class="comment">* and a new loadable category attached to that class. </span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Locking: loadMethodLock must be held by the caller </span></span><br><span class="line"><span class="comment">*   All other locks must not be held.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">void</span> call_load_methods(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> loading = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">bool</span> more_categories;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-entrant calls do nothing; the outermost call will finish the job.</span></span><br><span class="line">    <span class="keyword">if</span> (loading) <span class="keyword">return</span>;</span><br><span class="line">    loading = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *pool = objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//  1.重复调用class +loads，直到没有其他类</span></span><br><span class="line">        <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            call_class_loads(); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. Call category +loads ONCE</span></span><br><span class="line">        more_categories = call_category_loads();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. Run more +loads if there are classes OR more untried categories</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories);</span><br><span class="line"></span><br><span class="line">    objc_autoreleasePoolPop(pool);</span><br><span class="line"></span><br><span class="line">    loading = <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* call_class_loads</span></span><br><span class="line"><span class="comment">* Call all pending class +load methods.</span></span><br><span class="line"><span class="comment">* If new classes become loadable, +load is NOT called for them.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Called only by call_load_methods().</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> call_class_loads(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ...................</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Call all +loads for the detached list.</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123;</span><br><span class="line">        Class cls = classes[i].cls;</span><br><span class="line">        <span class="comment">// typedef void(*load_method_t)(id, SEL); 函数指针</span></span><br><span class="line">        load_method_t load_method = (load_method_t)classes[i].method;</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (PrintLoading) &#123;</span><br><span class="line">            _objc_inform(<span class="string">&quot;LOAD: +[%s load]\n&quot;</span>, cls-&gt;nameForLogging());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用函数</span></span><br><span class="line">        (*load_method)(cls, <span class="keyword">@selector</span>(load));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Destroy the detached list.</span></span><br><span class="line">    <span class="keyword">if</span> (classes) free(classes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* call_category_loads</span></span><br><span class="line"><span class="comment">* Call some pending category +load methods.</span></span><br><span class="line"><span class="comment">* The parent class of the +load-implementing categories has all of </span></span><br><span class="line"><span class="comment">*   its categories attached, in case some are lazily waiting for +initalize.</span></span><br><span class="line"><span class="comment">* Don&#x27;t call +load unless the parent class is connected.</span></span><br><span class="line"><span class="comment">* If new categories become loadable, +load is NOT called, and they </span></span><br><span class="line"><span class="comment">*   are added to the end of the loadable list, and we return TRUE.</span></span><br><span class="line"><span class="comment">* Return FALSE if no new categories became loadable.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Called only by call_load_methods().</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> call_category_loads(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ...................</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call all +loads for the detached list.</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123;</span><br><span class="line">        Category cat = cats[i].cat;</span><br><span class="line">        <span class="comment">// 直接找到load函数指针</span></span><br><span class="line">        <span class="comment">// typedef void(*load_method_t)(id, SEL); 函数指针</span></span><br><span class="line">        load_method_t load_method = (load_method_t)cats[i].method;</span><br><span class="line">        Class cls;</span><br><span class="line">        <span class="keyword">if</span> (!cat) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        cls = _category_getClass(cat);</span><br><span class="line">        <span class="keyword">if</span> (cls  &amp;&amp;  cls-&gt;isLoadable()) &#123;</span><br><span class="line">           ...................</span><br><span class="line">            <span class="comment">// 调用load函数</span></span><br><span class="line">            (*load_method)(cls, <span class="keyword">@selector</span>(load));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     ...................</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><code>call_class_loads();</code>  </li>
<li><code>call_category_loads(); </code>  </li>
<li>从这两处可以看出，先调用类的<code>load</code>方法，再调用分类的<code>load</code>方法</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><code>load_method_t load_method = (load_method_t)cats[i].method;</code> </li>
<li><code>(*load_method)(cls, @selector(load));</code> </li>
<li>通过这两句代码可以看出，<code>load</code>方法是直接找到<code>load函数(方法)</code> 的指针，通过指针调用的<code>load函数</code>，不是通过<code>OBJC</code>的消息机制</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><code>+load</code>方法会在<code>runtime</code>加载类、分类时调用，每个类、分类的<code>+load</code>，在程序运行过程中只调用一次</li>
</ul>
</blockquote>
<h5><span id="load-diao-yong-shun-xu">load调用顺序</span><a href="#load-diao-yong-shun-xu" class="header-anchor">#</a></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_load_methods</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ....................</span><br><span class="line">    <span class="keyword">void</span> *pool = objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//  1.重复调用class +loads，直到没有其他类</span></span><br><span class="line">        <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 先调用类</span></span><br><span class="line">            call_class_loads(); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. Call category +loads ONCE （再调用分类）</span></span><br><span class="line">        more_categories = call_category_loads();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. Run more +loads if there are classes OR more untried categories</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories);</span><br><span class="line"></span><br><span class="line">    objc_autoreleasePoolPop(pool);</span><br><span class="line"></span><br><span class="line">    loading = NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare_load_methods</span><span class="params">(<span class="keyword">const</span> headerType *mhdr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    .........</span><br><span class="line">    <span class="keyword">classref_t</span> <span class="keyword">const</span> *classlist = </span><br><span class="line">        _getObjc2NonlazyClassList(mhdr, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">// 按照编译顺序，将类的数据加进去</span></span><br><span class="line">        schedule_class_load(remapClass(classlist[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...........</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* prepare_load_methods</span></span><br><span class="line"><span class="comment">* Schedule +load for classes in this image, any un-+load-ed </span></span><br><span class="line"><span class="comment">* superclasses in other images, and any categories in this image.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="comment">// Recursively schedule +load for cls and any un-+load-ed superclasses.</span></span><br><span class="line"><span class="comment">// cls must already be connected.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">schedule_class_load</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   ..........</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure superclass-first ordering(递归调用,始终先添加父类方法，父类都放入后，开始放入子类对象)</span></span><br><span class="line">    schedule_class_load(cls-&gt;getSuperclass());</span><br><span class="line">    <span class="comment">// 将cls添加到loadable_classes数组的最后面</span></span><br><span class="line">    add_class_to_loadable_list(cls);</span><br><span class="line">    cls-&gt;setInfo(RW_LOADED); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><code>schedule_class_load(cls-&gt;getSuperclass());</code><br>通过这里可以看出是先调用父类的load方法，再调用子类的load方法</li>
</ul>
</blockquote>
<ul>
<li><p>先调用类的<code>+load</code></p>
<ul>
<li>按照编译先后顺序调用（先编译，先调用）</li>
<li>调用子类的<code>+load</code>之前会先调用父类的<code>+load</code></li>
</ul>
</li>
<li><p>再调用分类的<code>+load</code></p>
<ul>
<li>按照编译先后顺序调用（先编译，先调用）</li>
</ul>
</li>
</ul>
<h4><span id="initialize-chu-shi-hua">+ initialize (初始化)</span><a href="#initialize-chu-shi-hua" class="header-anchor">#</a></h4><p>源码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* class_initialize.  Send the &#x27;+initialize&#x27; message on demand to any</span></span><br><span class="line"><span class="comment">* uninitialized class. Force initialization of superclasses first.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initializeNonMetaClass</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/****************优先调用父类的initialize方法**********************/</span></span><br><span class="line">    <span class="comment">// Make sure super is done initializing BEFORE beginning to initialize cls.</span></span><br><span class="line">    <span class="comment">// See note about deadlock above.</span></span><br><span class="line">    supercls = cls-&gt;getSuperclass();</span><br><span class="line">    <span class="keyword">if</span> (supercls  &amp;&amp;  !supercls-&gt;isInitialized()) &#123;</span><br><span class="line">        <span class="comment">// 递归</span></span><br><span class="line">        initializeNonMetaClass(supercls);</span><br><span class="line">    &#125;</span><br><span class="line">        @<span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">            ...................调用initialize方法.....................</span></span><br><span class="line"><span class="comment">        **********************************************************************/</span></span><br><span class="line">            callInitialize(cls);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (PrintInitializing) &#123;</span><br><span class="line">                _objc_inform(<span class="string">&quot;INITIALIZE: thread %p: finished +[%s initialize]&quot;</span>,</span><br><span class="line">                             objc_thread_self(), cls-&gt;nameForLogging());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callInitialize</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ((<span class="keyword">void</span>(*)(Class, SEL))objc_msgSend)(cls, @selector(initialize));</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><p> <code>initializeNonMetaClass(supercls);</code><br>先调用父类的<code>initialize</code>方法,同时这里进行了判断</p>
</li>
<li><p><code>if (supercls  &amp;&amp;  !supercls-&gt;isInitialized()) &#123;</code></p>
</li>
<li><p>如果父类已经调用过<code>initialize</code>，不会重复调用</p>
</li>
<li><p>如果两个类，是同一个父类，并且这两个类的都没有实现<code>initialize</code>，父类的<code>initialize</code>会实现两遍（<code>父类的initialize可能会调用多次</code>），因为<code>initialize</code>是通过<code>OBJC</code>的消息机制调用的</p>
</li>
<li><p>如果类A自己没有实现<code>initialize</code>，但是父类实现了<code>initialize</code>，父类的<code>initialize</code>会调用两次，因为<code>initialize</code>是通过<code>OBJC</code>的消息机制调用的</p>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li> <code>((void(*)(Class, SEL))objc_msgSend)(cls, @selector(initialize));</code><br>说明<code>initialize</code> 是走的<code>OBJC</code>的消息发送机制</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><code>+initialize</code>方法会在类第一次接收到消息时调用</li>
</ul>
</blockquote>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4d36fd79f1a4444a12348e93b1a21a7~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-03-15 上午11.32.56.png"></p>
<p><strong><code>+initialize</code>和<code>+load</code>的很大区别是，<code>+initialize</code>是通过<code>objc_msgSend</code>进行调用的，所以有以下特点</strong></p>
<ul>
<li>如果子类没有实现<code>+initialize</code>，会调用父类的<code>+initialize</code></li>
<li>如果分类实现了<code>+initialize</code>，就覆盖类本身的<code>+initialize</code>调用 </li>
</ul>
<p><strong><code>+initialize</code>和<code>+load</code>的区别</strong></p>
<p>1.调用方式</p>
<ul>
<li>load是根据函数地址直接调用</li>
<li>initialize是通过objc_msgSend调用</li>
</ul>
<p>2.调用时刻</p>
<ul>
<li>load是runtime加载类、分类的时候调用（只会调用1次）</li>
<li>initialize是类第一次接收到消息的时候调用，每一个类只会initialize一次（父类的initialize方法可能会被调用多次）</li>
</ul>
<p>load、initialize的调用顺序？</p>
<p>1.load</p>
<p>1&gt; 先调用类的load</p>
<p>a) 先编译的类，优先调用load</p>
<p>b) 调用子类的load之前，会先调用父类的load</p>
<p>2&gt; 再调用分类的load</p>
<p>a) 先编译的分类，优先调用load</p>
<p>2.initialize</p>
<p>1&gt; 先初始化父类</p>
<p>2&gt; 再初始化子类（可能最终调用的是父类的initialize方法）</p>
<blockquote>
<p> 通常情况下两者都是只实现一次，不会重复实现。但是不排除重复实现的可能，譬如误操作直接调用这种，建议使用的时候加上<code>dispatch_once</code> 来使用</p>
</blockquote>
<h4><span id="guan-lian-dui-xiang-gei-fen-lei-tian-jia-shu-xing">关联对象（给分类添加属性）</span><a href="#guan-lian-dui-xiang-gei-fen-lei-tian-jia-shu-xing" class="header-anchor">#</a></h4><p><strong>在类中声明一个属性，会做三件事情</strong></p>
<blockquote>
<ol>
<li>生成一个成员变量</li>
<li>生成get和set方法的声明</li>
<li>实现get和set方法的实现</li>
</ol>
</blockquote>
<p><strong>在分类中写一个属性</strong></p>
<blockquote>
<p>只会自动生成<code>get</code>和<code>set</code>方法的<code>声明</code>，不会生成方法实现，不会生成成员变量</p>
</blockquote>
<p><strong>默认情况下，因为分类底层结构的限制，不能添加成员变量到分类中。但可以通过关联对象来间接实现</strong></p>
<blockquote>
<p>对比看的话类的结构中，有成员变量列表<code>ivars</code>(只读)，用来存储成员变量，通过关联对象添加的成员变量，并不是放到类的<code>ivars</code>中</p>
</blockquote>
<ul>
<li><p>类的结构：<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fca529bcb6c043b4b23050c5292b169e~tplv-k3u1fbpfcp-watermark.image" alt="01-OC语法.png"></p>
</li>
<li><p>分类的结构</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">category_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">// 类名</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">class_t</span> *<span class="title">cls</span>;</span> <span class="comment">//</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">method_list_t</span> *<span class="title">instance_methods</span>;</span> <span class="comment">// 对象方法</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">method_list_t</span> *<span class="title">class_methods</span>;</span>   <span class="comment">//  类方法</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span>   <span class="comment">//  协议</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">prop_list_t</span> *<span class="title">properties</span>;</span>   <span class="comment">//  属性</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>关联对象提供了以下API</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 添加关联对象</span><br><span class="line">void objc_setAssociatedObject(id object, const void * key,</span><br><span class="line">                                id value, objc_AssociationPolicy policy)</span><br><span class="line"></span><br><span class="line">2. 获得关联对象</span><br><span class="line">id objc_getAssociatedObject(id object, const void * key)</span><br><span class="line"></span><br><span class="line">3. 移除所有的关联对象</span><br><span class="line">void objc_removeAssociatedObjects(id object)</span><br></pre></td></tr></table></figure>


<p><strong><code>const</code>修饰的是全局变量，外部可以通过<code>extern</code>关键字进行访问，给全局变量加上<code>static</code>意味着只有当前文件内部可以访问</strong> </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h </span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">char</span> outKey（编译成功）</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">char</span> privateKey （编译报错）</span><br><span class="line"></span><br><span class="line"><span class="comment">// .m</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> outKey (外部可以通过<span class="keyword">extern</span>访问)</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> privateKey (因为有<span class="keyword">static</span>，外部无法访问)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5><span id="key-de-chang-jian-yong-fa">key的常见用法</span><a href="#key-de-chang-jian-yong-fa" class="header-anchor">#</a></h5><ul>
<li><p>使用变量地址值，赋值比较啰嗦，切占8个字节(指针变量)</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *MyKey = &amp;MyKey;</span><br><span class="line">objc_setAssociatedObject(obj, MyKey, value, OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><br><span class="line">objc_getAssociatedObject(obj, MyKey)</span><br></pre></td></tr></table></figure></li>
<li><p>还是使用变量地址，但是只占一个字节（char变量）</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> MyKey;</span><br><span class="line">objc_setAssociatedObject(obj, &amp;MyKey, value, OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><br><span class="line">objc_getAssociatedObject(obj, &amp;MyKey)</span><br></pre></td></tr></table></figure></li>
<li><p>使用属性名作为key(@”property”在常量区，内存地址一致)</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objc_setAssociatedObject(obj, <span class="string">@&quot;property&quot;</span>, value, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">objc_getAssociatedObject(obj, <span class="string">@&quot;property&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>使用get方法的@selecor作为key</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objc_setAssociatedObject(obj, <span class="keyword">@selector</span>(<span class="keyword">getter</span>), value, OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><br><span class="line">objc_getAssociatedObject(obj, _cmd) <span class="comment">// _cmd == @selector(getter)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>API</strong> </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Sets an associated value for a given object using a given key and association policy.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param object 关联对象（一般是self）</span></span><br><span class="line"><span class="comment"> * @param key 关联的关键词</span></span><br><span class="line"><span class="comment"> * @param value 关联的数值，传nil移除关联对象</span></span><br><span class="line"><span class="comment"> * @param policy 关联策略</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @see objc_setAssociatedObject</span></span><br><span class="line"><span class="comment"> * @see objc_removeAssociatedObjects</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">OBJC_EXPORT <span class="keyword">void</span></span><br><span class="line">objc_setAssociatedObject(<span class="keyword">id</span> _Nonnull object, <span class="keyword">const</span> <span class="keyword">void</span> * _Nonnull key,</span><br><span class="line">                         <span class="keyword">id</span> _Nullable value, objc_AssociationPolicy policy)</span><br><span class="line">    OBJC_AVAILABLE(<span class="number">10.6</span>, <span class="number">3.1</span>, <span class="number">9.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Returns the value associated with a given object for a given key.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param object 关联对象</span></span><br><span class="line"><span class="comment"> * @param key 关联的关键词</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return The value associated with the key \e key for \e object.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @see objc_setAssociatedObject</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">OBJC_EXPORT <span class="keyword">id</span> _Nullable</span><br><span class="line">objc_getAssociatedObject(<span class="keyword">id</span> _Nonnull object, <span class="keyword">const</span> <span class="keyword">void</span> * _Nonnull key)</span><br><span class="line">    OBJC_AVAILABLE(<span class="number">10.6</span>, <span class="number">3.1</span>, <span class="number">9.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>);</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p><strong>实际使用</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(name), name, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 隐式参数</span></span><br><span class="line">    <span class="comment">// _cmd == @selector(name)</span></span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, _cmd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>objc_AssociationPolicy (关联策略)</strong></p>
<p>没有<code>weak</code>效果，使用要注意，离开赋值范围要手动设置<code>nil</code></p>
<table>
<thead>
<tr>
<th>objc_AssociationPolicy</th>
<th>对应的修饰符</th>
</tr>
</thead>
<tbody><tr>
<td><code>OBJC_ASSOCIATION_ASSIGN </code></td>
<td><code>assign</code></td>
</tr>
<tr>
<td><code>OBJC_ASSOCIATION_RETAIN_NONATOMIC</code></td>
<td><code>strong, nonatomic</code></td>
</tr>
<tr>
<td><code>OBJC_ASSOCIATION_COPY_NONATOMIC</code></td>
<td><code>copy, nonatomic</code></td>
</tr>
<tr>
<td><code>OBJC_ASSOCIATION_RETAIN</code></td>
<td><code>strong, atomic</code></td>
</tr>
<tr>
<td><code>OBJC_ASSOCIATION_COPY</code></td>
<td><code>copy, atomic</code></td>
</tr>
</tbody></table>
<h5><span id="guan-lian-dui-xiang-yuan-li-di-ceng-shi-xian">关联对象原理(底层实现)</span><a href="#guan-lian-dui-xiang-yuan-li-di-ceng-shi-xian" class="header-anchor">#</a></h5><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4eba97fea4f64af4888280a34b819235~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-03-15 下午3.26.30.png"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c1bbf14d3bd4c62b0e127ab37d16cac~tplv-k3u1fbpfcp-zoom-1.image" alt="关联对象原理.png"></p>
<blockquote>
<p>全局有一个<code>AssociationsManager</code>，里面保存一个成员变量</p>
<p><code>AssociationsHashMap *map&#123;关联对象(object): ObjectAssociationMap&#125;</code></p>
<p>根据<code>关联对象</code>，可以得到一个</p>
<p><code>AssociationMap &#123;key:ObjcAssociation&#125;对象</code>，</p>
<p><code>ObjcAssociation</code>有两个属性 {<code>value</code>,<code>policy</code>}</p>
</blockquote>
<p>关联对象不会增加<code>成员变量</code>，不能通过<code>person -&gt; age</code> 形式进行访问</p>
</p></div><div class="share"><span>Share</span>&nbsp;<span class="soc"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></span><span class="soc"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></span><span class="soc"><a target="_blank" rel="noopener" href="http://twitter.com/home?status=http://example.com/2021/03/08/底层三：category/%20Hexo%20底层三：Category" class="fa fa-twitter"></a></span></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/2021/03/08/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/" title="网络安全"><i class="fa fa-angle-double-left"></i>&nbsp;Previous post: 网络安全</a></span><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/2021/03/08/%E5%BA%95%E5%B1%82%E4%BA%94%EF%BC%9ARuntime/" title="底层五：Runtime">Next post: 底层五：Runtime&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2021&nbsp;<a target="_blank" href="http://example.com" rel="noopener noreferrer">John Doe</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script></body></html>